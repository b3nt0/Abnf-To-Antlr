/*

    Copyright 2012-2013 Robert Pinchbeck
  
    This file is part of AbnfToAntlr.

    AbnfToAntlr is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    AbnfToAntlr is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with AbnfToAntlr.  If not, see <http://www.gnu.org/licenses/>.
  
*/

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 AbnfAst.g 2012-11-12 22:26:59

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
public partial class AbnfAstLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ALTERNATION_NODE=4;
	public const int ASTERISK=5;
	public const int BIN_VAL_CONCAT_NODE=6;
	public const int BIN_VAL_NODE=7;
	public const int BIN_VAL_NUMBER_NODE=8;
	public const int BIN_VAL_PREFIX=9;
	public const int BIN_VAL_RANGE_NODE=10;
	public const int CHAR_VAL=11;
	public const int CHAR_VAL_NODE=12;
	public const int COMMENT=13;
	public const int CONCATENATION_NODE=14;
	public const int CR=15;
	public const int CRLF=16;
	public const int DASH=17;
	public const int DEC_VAL_CONCAT_NODE=18;
	public const int DEC_VAL_NODE=19;
	public const int DEC_VAL_NUMBER_NODE=20;
	public const int DEC_VAL_PREFIX=21;
	public const int DEC_VAL_RANGE_NODE=22;
	public const int DQUOTE=23;
	public const int EXACT_OCCURENCES=24;
	public const int GROUP_NODE=25;
	public const int HEX_ALPHA=26;
	public const int HEX_VAL_CONCAT_NODE=27;
	public const int HEX_VAL_NODE=28;
	public const int HEX_VAL_NUMBER_NODE=29;
	public const int HEX_VAL_PREFIX=30;
	public const int HEX_VAL_RANGE_NODE=31;
	public const int HTAB=32;
	public const int LF=33;
	public const int NUMBER_NODE=34;
	public const int ONE=35;
	public const int ONE_OCCURENCE=36;
	public const int OPTION_NODE=37;
	public const int ORMORE_OCCURENCES=38;
	public const int OTHER_ALPHA=39;
	public const int OTHER_DIGIT=40;
	public const int PROSE_VAL=41;
	public const int PROSE_VAL_NODE=42;
	public const int REPEAT_NODE=43;
	public const int REPETITION_NODE=44;
	public const int RULE_LIST_NODE=45;
	public const int RULE_NAME_NODE=46;
	public const int RULE_NODE=47;
	public const int SP=48;
	public const int VCHAR=49;
	public const int WSP=50;
	public const int ZERO=51;
	public const int ZERO_OCCURENCES=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;

    // delegates
    // delegators

	public AbnfAstLexer()
	{
		OnCreated();
	}

	public AbnfAstLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public AbnfAstLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "AbnfAst.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_T__53();
	partial void LeaveRule_T__53();

	// $ANTLR start "T__53"
	[GrammarRule("T__53")]
	private void mT__53()
	{
		EnterRule_T__53();
		EnterRule("T__53", 1);
		TraceIn("T__53", 1);
		try
		{
			int _type = T__53;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:7:7: ( '(' )
			DebugEnterAlt(1);
			// AbnfAst.g:7:9: '('
			{
			DebugLocation(7, 9);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__53", 1);
			LeaveRule("T__53", 1);
			LeaveRule_T__53();
		}
	}
	// $ANTLR end "T__53"

	partial void EnterRule_T__54();
	partial void LeaveRule_T__54();

	// $ANTLR start "T__54"
	[GrammarRule("T__54")]
	private void mT__54()
	{
		EnterRule_T__54();
		EnterRule("T__54", 2);
		TraceIn("T__54", 2);
		try
		{
			int _type = T__54;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:8:7: ( ')' )
			DebugEnterAlt(1);
			// AbnfAst.g:8:9: ')'
			{
			DebugLocation(8, 9);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__54", 2);
			LeaveRule("T__54", 2);
			LeaveRule_T__54();
		}
	}
	// $ANTLR end "T__54"

	partial void EnterRule_T__55();
	partial void LeaveRule_T__55();

	// $ANTLR start "T__55"
	[GrammarRule("T__55")]
	private void mT__55()
	{
		EnterRule_T__55();
		EnterRule("T__55", 3);
		TraceIn("T__55", 3);
		try
		{
			int _type = T__55;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:9:7: ( '.' )
			DebugEnterAlt(1);
			// AbnfAst.g:9:9: '.'
			{
			DebugLocation(9, 9);
			Match('.'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__55", 3);
			LeaveRule("T__55", 3);
			LeaveRule_T__55();
		}
	}
	// $ANTLR end "T__55"

	partial void EnterRule_T__56();
	partial void LeaveRule_T__56();

	// $ANTLR start "T__56"
	[GrammarRule("T__56")]
	private void mT__56()
	{
		EnterRule_T__56();
		EnterRule("T__56", 4);
		TraceIn("T__56", 4);
		try
		{
			int _type = T__56;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:10:7: ( '/' )
			DebugEnterAlt(1);
			// AbnfAst.g:10:9: '/'
			{
			DebugLocation(10, 9);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__56", 4);
			LeaveRule("T__56", 4);
			LeaveRule_T__56();
		}
	}
	// $ANTLR end "T__56"

	partial void EnterRule_T__57();
	partial void LeaveRule_T__57();

	// $ANTLR start "T__57"
	[GrammarRule("T__57")]
	private void mT__57()
	{
		EnterRule_T__57();
		EnterRule("T__57", 5);
		TraceIn("T__57", 5);
		try
		{
			int _type = T__57;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:11:7: ( '=' )
			DebugEnterAlt(1);
			// AbnfAst.g:11:9: '='
			{
			DebugLocation(11, 9);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__57", 5);
			LeaveRule("T__57", 5);
			LeaveRule_T__57();
		}
	}
	// $ANTLR end "T__57"

	partial void EnterRule_T__58();
	partial void LeaveRule_T__58();

	// $ANTLR start "T__58"
	[GrammarRule("T__58")]
	private void mT__58()
	{
		EnterRule_T__58();
		EnterRule("T__58", 6);
		TraceIn("T__58", 6);
		try
		{
			int _type = T__58;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:12:7: ( '=/' )
			DebugEnterAlt(1);
			// AbnfAst.g:12:9: '=/'
			{
			DebugLocation(12, 9);
			Match("=/"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__58", 6);
			LeaveRule("T__58", 6);
			LeaveRule_T__58();
		}
	}
	// $ANTLR end "T__58"

	partial void EnterRule_T__59();
	partial void LeaveRule_T__59();

	// $ANTLR start "T__59"
	[GrammarRule("T__59")]
	private void mT__59()
	{
		EnterRule_T__59();
		EnterRule("T__59", 7);
		TraceIn("T__59", 7);
		try
		{
			int _type = T__59;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:13:7: ( '[' )
			DebugEnterAlt(1);
			// AbnfAst.g:13:9: '['
			{
			DebugLocation(13, 9);
			Match('['); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__59", 7);
			LeaveRule("T__59", 7);
			LeaveRule_T__59();
		}
	}
	// $ANTLR end "T__59"

	partial void EnterRule_T__60();
	partial void LeaveRule_T__60();

	// $ANTLR start "T__60"
	[GrammarRule("T__60")]
	private void mT__60()
	{
		EnterRule_T__60();
		EnterRule("T__60", 8);
		TraceIn("T__60", 8);
		try
		{
			int _type = T__60;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:14:7: ( ']' )
			DebugEnterAlt(1);
			// AbnfAst.g:14:9: ']'
			{
			DebugLocation(14, 9);
			Match(']'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__60", 8);
			LeaveRule("T__60", 8);
			LeaveRule_T__60();
		}
	}
	// $ANTLR end "T__60"

	partial void EnterRule_COMMENT();
	partial void LeaveRule_COMMENT();

	// $ANTLR start "COMMENT"
	[GrammarRule("COMMENT")]
	private void mCOMMENT()
	{
		EnterRule_COMMENT();
		EnterRule("COMMENT", 9);
		TraceIn("COMMENT", 9);
		try
		{
			int _type = COMMENT;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:262:2: ( ';' ( WSP | VCHAR )* CRLF )
			DebugEnterAlt(1);
			// AbnfAst.g:263:3: ';' ( WSP | VCHAR )* CRLF
			{
			DebugLocation(263, 3);
			Match(';'); 
			DebugLocation(263, 7);
			// AbnfAst.g:263:7: ( WSP | VCHAR )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=3;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1=='\t'||LA1_1==' '))
				{
					alt1 = 1;
				}
				else if (((LA1_1>='!' && LA1_1<='~')))
				{
					alt1 = 2;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:263:9: WSP
					{
					DebugLocation(263, 9);
					mWSP(); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AbnfAst.g:263:15: VCHAR
					{
					DebugLocation(263, 15);
					mVCHAR(); 

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(263, 24);
			mCRLF(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMENT", 9);
			LeaveRule("COMMENT", 9);
			LeaveRule_COMMENT();
		}
	}
	// $ANTLR end "COMMENT"

	partial void EnterRule_CHAR_VAL();
	partial void LeaveRule_CHAR_VAL();

	// $ANTLR start "CHAR_VAL"
	[GrammarRule("CHAR_VAL")]
	private void mCHAR_VAL()
	{
		EnterRule_CHAR_VAL();
		EnterRule("CHAR_VAL", 10);
		TraceIn("CHAR_VAL", 10);
		try
		{
			int _type = CHAR_VAL;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:267:2: ( DQUOTE ( '\\u0020' .. '\\u0021' | '\\u0023' .. '\\u007E' )* DQUOTE )
			DebugEnterAlt(1);
			// AbnfAst.g:268:3: DQUOTE ( '\\u0020' .. '\\u0021' | '\\u0023' .. '\\u007E' )* DQUOTE
			{
			DebugLocation(268, 3);
			mDQUOTE(); 
			DebugLocation(268, 10);
			// AbnfAst.g:268:10: ( '\\u0020' .. '\\u0021' | '\\u0023' .. '\\u007E' )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if (((LA2_1>=' ' && LA2_1<='!')||(LA2_1>='#' && LA2_1<='~')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:
					{
					DebugLocation(268, 10);
					input.Consume();


					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(268, 55);
			mDQUOTE(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CHAR_VAL", 10);
			LeaveRule("CHAR_VAL", 10);
			LeaveRule_CHAR_VAL();
		}
	}
	// $ANTLR end "CHAR_VAL"

	partial void EnterRule_BIN_VAL_PREFIX();
	partial void LeaveRule_BIN_VAL_PREFIX();

	// $ANTLR start "BIN_VAL_PREFIX"
	[GrammarRule("BIN_VAL_PREFIX")]
	private void mBIN_VAL_PREFIX()
	{
		EnterRule_BIN_VAL_PREFIX();
		EnterRule("BIN_VAL_PREFIX", 11);
		TraceIn("BIN_VAL_PREFIX", 11);
		try
		{
			int _type = BIN_VAL_PREFIX;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:272:2: ( '%b' )
			DebugEnterAlt(1);
			// AbnfAst.g:273:3: '%b'
			{
			DebugLocation(273, 3);
			Match("%b"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BIN_VAL_PREFIX", 11);
			LeaveRule("BIN_VAL_PREFIX", 11);
			LeaveRule_BIN_VAL_PREFIX();
		}
	}
	// $ANTLR end "BIN_VAL_PREFIX"

	partial void EnterRule_DEC_VAL_PREFIX();
	partial void LeaveRule_DEC_VAL_PREFIX();

	// $ANTLR start "DEC_VAL_PREFIX"
	[GrammarRule("DEC_VAL_PREFIX")]
	private void mDEC_VAL_PREFIX()
	{
		EnterRule_DEC_VAL_PREFIX();
		EnterRule("DEC_VAL_PREFIX", 12);
		TraceIn("DEC_VAL_PREFIX", 12);
		try
		{
			int _type = DEC_VAL_PREFIX;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:277:2: ( '%d' )
			DebugEnterAlt(1);
			// AbnfAst.g:278:3: '%d'
			{
			DebugLocation(278, 3);
			Match("%d"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DEC_VAL_PREFIX", 12);
			LeaveRule("DEC_VAL_PREFIX", 12);
			LeaveRule_DEC_VAL_PREFIX();
		}
	}
	// $ANTLR end "DEC_VAL_PREFIX"

	partial void EnterRule_HEX_VAL_PREFIX();
	partial void LeaveRule_HEX_VAL_PREFIX();

	// $ANTLR start "HEX_VAL_PREFIX"
	[GrammarRule("HEX_VAL_PREFIX")]
	private void mHEX_VAL_PREFIX()
	{
		EnterRule_HEX_VAL_PREFIX();
		EnterRule("HEX_VAL_PREFIX", 13);
		TraceIn("HEX_VAL_PREFIX", 13);
		try
		{
			int _type = HEX_VAL_PREFIX;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:282:2: ( '%x' )
			DebugEnterAlt(1);
			// AbnfAst.g:283:3: '%x'
			{
			DebugLocation(283, 3);
			Match("%x"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("HEX_VAL_PREFIX", 13);
			LeaveRule("HEX_VAL_PREFIX", 13);
			LeaveRule_HEX_VAL_PREFIX();
		}
	}
	// $ANTLR end "HEX_VAL_PREFIX"

	partial void EnterRule_PROSE_VAL();
	partial void LeaveRule_PROSE_VAL();

	// $ANTLR start "PROSE_VAL"
	[GrammarRule("PROSE_VAL")]
	private void mPROSE_VAL()
	{
		EnterRule_PROSE_VAL();
		EnterRule("PROSE_VAL", 14);
		TraceIn("PROSE_VAL", 14);
		try
		{
			int _type = PROSE_VAL;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:287:2: ( '<' ( '\\u0020' .. '\\u003D' | '\\u003F' .. '\\u007E' )* '>' )
			DebugEnterAlt(1);
			// AbnfAst.g:288:3: '<' ( '\\u0020' .. '\\u003D' | '\\u003F' .. '\\u007E' )* '>'
			{
			DebugLocation(288, 3);
			Match('<'); 
			DebugLocation(288, 7);
			// AbnfAst.g:288:7: ( '\\u0020' .. '\\u003D' | '\\u003F' .. '\\u007E' )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if (((LA3_1>=' ' && LA3_1<='=')||(LA3_1>='?' && LA3_1<='~')))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:
					{
					DebugLocation(288, 7);
					input.Consume();


					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(288, 52);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PROSE_VAL", 14);
			LeaveRule("PROSE_VAL", 14);
			LeaveRule_PROSE_VAL();
		}
	}
	// $ANTLR end "PROSE_VAL"

	partial void EnterRule_HEX_ALPHA();
	partial void LeaveRule_HEX_ALPHA();

	// $ANTLR start "HEX_ALPHA"
	[GrammarRule("HEX_ALPHA")]
	private void mHEX_ALPHA()
	{
		EnterRule_HEX_ALPHA();
		EnterRule("HEX_ALPHA", 15);
		TraceIn("HEX_ALPHA", 15);
		try
		{
			int _type = HEX_ALPHA;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:292:2: ( 'A' .. 'F' )
			DebugEnterAlt(1);
			// AbnfAst.g:
			{
			DebugLocation(292, 2);
			if ((input.LA(1)>='A' && input.LA(1)<='F'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("HEX_ALPHA", 15);
			LeaveRule("HEX_ALPHA", 15);
			LeaveRule_HEX_ALPHA();
		}
	}
	// $ANTLR end "HEX_ALPHA"

	partial void EnterRule_OTHER_ALPHA();
	partial void LeaveRule_OTHER_ALPHA();

	// $ANTLR start "OTHER_ALPHA"
	[GrammarRule("OTHER_ALPHA")]
	private void mOTHER_ALPHA()
	{
		EnterRule_OTHER_ALPHA();
		EnterRule("OTHER_ALPHA", 16);
		TraceIn("OTHER_ALPHA", 16);
		try
		{
			int _type = OTHER_ALPHA;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:297:2: ( 'G' .. 'Z' | 'a' .. 'z' )
			DebugEnterAlt(1);
			// AbnfAst.g:
			{
			DebugLocation(297, 2);
			if ((input.LA(1)>='G' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OTHER_ALPHA", 16);
			LeaveRule("OTHER_ALPHA", 16);
			LeaveRule_OTHER_ALPHA();
		}
	}
	// $ANTLR end "OTHER_ALPHA"

	partial void EnterRule_ASTERISK();
	partial void LeaveRule_ASTERISK();

	// $ANTLR start "ASTERISK"
	[GrammarRule("ASTERISK")]
	private void mASTERISK()
	{
		EnterRule_ASTERISK();
		EnterRule("ASTERISK", 17);
		TraceIn("ASTERISK", 17);
		try
		{
			int _type = ASTERISK;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:302:2: ( '*' )
			DebugEnterAlt(1);
			// AbnfAst.g:303:3: '*'
			{
			DebugLocation(303, 3);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASTERISK", 17);
			LeaveRule("ASTERISK", 17);
			LeaveRule_ASTERISK();
		}
	}
	// $ANTLR end "ASTERISK"

	partial void EnterRule_DASH();
	partial void LeaveRule_DASH();

	// $ANTLR start "DASH"
	[GrammarRule("DASH")]
	private void mDASH()
	{
		EnterRule_DASH();
		EnterRule("DASH", 18);
		TraceIn("DASH", 18);
		try
		{
			int _type = DASH;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:307:2: ( '-' )
			DebugEnterAlt(1);
			// AbnfAst.g:308:3: '-'
			{
			DebugLocation(308, 3);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DASH", 18);
			LeaveRule("DASH", 18);
			LeaveRule_DASH();
		}
	}
	// $ANTLR end "DASH"

	partial void EnterRule_CR();
	partial void LeaveRule_CR();

	// $ANTLR start "CR"
	[GrammarRule("CR")]
	private void mCR()
	{
		EnterRule_CR();
		EnterRule("CR", 19);
		TraceIn("CR", 19);
		try
		{
			// AbnfAst.g:312:2: ( '\\u000D' )
			DebugEnterAlt(1);
			// AbnfAst.g:313:3: '\\u000D'
			{
			DebugLocation(313, 3);
			Match('\r'); 

			}

		}
		finally
		{
			TraceOut("CR", 19);
			LeaveRule("CR", 19);
			LeaveRule_CR();
		}
	}
	// $ANTLR end "CR"

	partial void EnterRule_CRLF();
	partial void LeaveRule_CRLF();

	// $ANTLR start "CRLF"
	[GrammarRule("CRLF")]
	private void mCRLF()
	{
		EnterRule_CRLF();
		EnterRule("CRLF", 20);
		TraceIn("CRLF", 20);
		try
		{
			int _type = CRLF;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:318:2: ( CR LF )
			DebugEnterAlt(1);
			// AbnfAst.g:319:3: CR LF
			{
			DebugLocation(319, 3);
			mCR(); 
			DebugLocation(319, 6);
			mLF(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CRLF", 20);
			LeaveRule("CRLF", 20);
			LeaveRule_CRLF();
		}
	}
	// $ANTLR end "CRLF"

	partial void EnterRule_ZERO();
	partial void LeaveRule_ZERO();

	// $ANTLR start "ZERO"
	[GrammarRule("ZERO")]
	private void mZERO()
	{
		EnterRule_ZERO();
		EnterRule("ZERO", 21);
		TraceIn("ZERO", 21);
		try
		{
			int _type = ZERO;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:324:2: ( '0' )
			DebugEnterAlt(1);
			// AbnfAst.g:325:3: '0'
			{
			DebugLocation(325, 3);
			Match('0'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ZERO", 21);
			LeaveRule("ZERO", 21);
			LeaveRule_ZERO();
		}
	}
	// $ANTLR end "ZERO"

	partial void EnterRule_ONE();
	partial void LeaveRule_ONE();

	// $ANTLR start "ONE"
	[GrammarRule("ONE")]
	private void mONE()
	{
		EnterRule_ONE();
		EnterRule("ONE", 22);
		TraceIn("ONE", 22);
		try
		{
			int _type = ONE;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:329:2: ( '1' )
			DebugEnterAlt(1);
			// AbnfAst.g:330:3: '1'
			{
			DebugLocation(330, 3);
			Match('1'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ONE", 22);
			LeaveRule("ONE", 22);
			LeaveRule_ONE();
		}
	}
	// $ANTLR end "ONE"

	partial void EnterRule_OTHER_DIGIT();
	partial void LeaveRule_OTHER_DIGIT();

	// $ANTLR start "OTHER_DIGIT"
	[GrammarRule("OTHER_DIGIT")]
	private void mOTHER_DIGIT()
	{
		EnterRule_OTHER_DIGIT();
		EnterRule("OTHER_DIGIT", 23);
		TraceIn("OTHER_DIGIT", 23);
		try
		{
			int _type = OTHER_DIGIT;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:334:2: ( '2' .. '9' )
			DebugEnterAlt(1);
			// AbnfAst.g:
			{
			DebugLocation(334, 2);
			if ((input.LA(1)>='2' && input.LA(1)<='9'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OTHER_DIGIT", 23);
			LeaveRule("OTHER_DIGIT", 23);
			LeaveRule_OTHER_DIGIT();
		}
	}
	// $ANTLR end "OTHER_DIGIT"

	partial void EnterRule_DQUOTE();
	partial void LeaveRule_DQUOTE();

	// $ANTLR start "DQUOTE"
	[GrammarRule("DQUOTE")]
	private void mDQUOTE()
	{
		EnterRule_DQUOTE();
		EnterRule("DQUOTE", 24);
		TraceIn("DQUOTE", 24);
		try
		{
			// AbnfAst.g:339:2: ( '\\u0022' )
			DebugEnterAlt(1);
			// AbnfAst.g:340:3: '\\u0022'
			{
			DebugLocation(340, 3);
			Match('\"'); 

			}

		}
		finally
		{
			TraceOut("DQUOTE", 24);
			LeaveRule("DQUOTE", 24);
			LeaveRule_DQUOTE();
		}
	}
	// $ANTLR end "DQUOTE"

	partial void EnterRule_HTAB();
	partial void LeaveRule_HTAB();

	// $ANTLR start "HTAB"
	[GrammarRule("HTAB")]
	private void mHTAB()
	{
		EnterRule_HTAB();
		EnterRule("HTAB", 25);
		TraceIn("HTAB", 25);
		try
		{
			// AbnfAst.g:345:2: ( '\\u0009' )
			DebugEnterAlt(1);
			// AbnfAst.g:346:3: '\\u0009'
			{
			DebugLocation(346, 3);
			Match('\t'); 

			}

		}
		finally
		{
			TraceOut("HTAB", 25);
			LeaveRule("HTAB", 25);
			LeaveRule_HTAB();
		}
	}
	// $ANTLR end "HTAB"

	partial void EnterRule_LF();
	partial void LeaveRule_LF();

	// $ANTLR start "LF"
	[GrammarRule("LF")]
	private void mLF()
	{
		EnterRule_LF();
		EnterRule("LF", 26);
		TraceIn("LF", 26);
		try
		{
			// AbnfAst.g:351:2: ( '\\u000A' )
			DebugEnterAlt(1);
			// AbnfAst.g:352:3: '\\u000A'
			{
			DebugLocation(352, 3);
			Match('\n'); 

			}

		}
		finally
		{
			TraceOut("LF", 26);
			LeaveRule("LF", 26);
			LeaveRule_LF();
		}
	}
	// $ANTLR end "LF"

	partial void EnterRule_SP();
	partial void LeaveRule_SP();

	// $ANTLR start "SP"
	[GrammarRule("SP")]
	private void mSP()
	{
		EnterRule_SP();
		EnterRule("SP", 27);
		TraceIn("SP", 27);
		try
		{
			// AbnfAst.g:357:2: ( '\\u0020' )
			DebugEnterAlt(1);
			// AbnfAst.g:358:3: '\\u0020'
			{
			DebugLocation(358, 3);
			Match(' '); 

			}

		}
		finally
		{
			TraceOut("SP", 27);
			LeaveRule("SP", 27);
			LeaveRule_SP();
		}
	}
	// $ANTLR end "SP"

	partial void EnterRule_VCHAR();
	partial void LeaveRule_VCHAR();

	// $ANTLR start "VCHAR"
	[GrammarRule("VCHAR")]
	private void mVCHAR()
	{
		EnterRule_VCHAR();
		EnterRule("VCHAR", 28);
		TraceIn("VCHAR", 28);
		try
		{
			// AbnfAst.g:363:2: ( '\\u0021' .. '\\u007E' )
			DebugEnterAlt(1);
			// AbnfAst.g:
			{
			DebugLocation(363, 2);
			if ((input.LA(1)>='!' && input.LA(1)<='~'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("VCHAR", 28);
			LeaveRule("VCHAR", 28);
			LeaveRule_VCHAR();
		}
	}
	// $ANTLR end "VCHAR"

	partial void EnterRule_WSP();
	partial void LeaveRule_WSP();

	// $ANTLR start "WSP"
	[GrammarRule("WSP")]
	private void mWSP()
	{
		EnterRule_WSP();
		EnterRule("WSP", 29);
		TraceIn("WSP", 29);
		try
		{
			int _type = WSP;
			int _channel = DefaultTokenChannel;
			// AbnfAst.g:369:2: ( ( SP | HTAB )+ )
			DebugEnterAlt(1);
			// AbnfAst.g:370:3: ( SP | HTAB )+
			{
			DebugLocation(370, 3);
			// AbnfAst.g:370:3: ( SP | HTAB )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1=='\t'||LA4_1==' '))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:
					{
					DebugLocation(370, 3);
					input.Consume();


					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WSP", 29);
			LeaveRule("WSP", 29);
			LeaveRule_WSP();
		}
	}
	// $ANTLR end "WSP"

	public override void mTokens()
	{
		// AbnfAst.g:1:8: ( T__53 | T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | COMMENT | CHAR_VAL | BIN_VAL_PREFIX | DEC_VAL_PREFIX | HEX_VAL_PREFIX | PROSE_VAL | HEX_ALPHA | OTHER_ALPHA | ASTERISK | DASH | CRLF | ZERO | ONE | OTHER_DIGIT | WSP )
		int alt5=23;
		try { DebugEnterDecision(5, false);
		switch (input.LA(1))
		{
		case '(':
			{
			alt5 = 1;
			}
			break;
		case ')':
			{
			alt5 = 2;
			}
			break;
		case '.':
			{
			alt5 = 3;
			}
			break;
		case '/':
			{
			alt5 = 4;
			}
			break;
		case '=':
			{
			int LA5_2 = input.LA(2);

			if ((LA5_2=='/'))
			{
				alt5 = 6;
			}
			else
			{
				alt5 = 5;
			}
			}
			break;
		case '[':
			{
			alt5 = 7;
			}
			break;
		case ']':
			{
			alt5 = 8;
			}
			break;
		case ';':
			{
			alt5 = 9;
			}
			break;
		case '\"':
			{
			alt5 = 10;
			}
			break;
		case '%':
			{
			switch (input.LA(2))
			{
			case 'b':
				{
				alt5 = 11;
				}
				break;
			case 'd':
				{
				alt5 = 12;
				}
				break;
			case 'x':
				{
				alt5 = 13;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			}
			break;
		case '<':
			{
			alt5 = 14;
			}
			break;
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
			{
			alt5 = 15;
			}
			break;
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':
			{
			alt5 = 16;
			}
			break;
		case '*':
			{
			alt5 = 17;
			}
			break;
		case '-':
			{
			alt5 = 18;
			}
			break;
		case '\r':
			{
			alt5 = 19;
			}
			break;
		case '0':
			{
			alt5 = 20;
			}
			break;
		case '1':
			{
			alt5 = 21;
			}
			break;
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			{
			alt5 = 22;
			}
			break;
		case '\t':
		case ' ':
			{
			alt5 = 23;
			}
			break;
		default:
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}

		} finally { DebugExitDecision(5); }
		switch (alt5)
		{
		case 1:
			DebugEnterAlt(1);
			// AbnfAst.g:1:10: T__53
			{
			DebugLocation(1, 10);
			mT__53(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// AbnfAst.g:1:16: T__54
			{
			DebugLocation(1, 16);
			mT__54(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// AbnfAst.g:1:22: T__55
			{
			DebugLocation(1, 22);
			mT__55(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// AbnfAst.g:1:28: T__56
			{
			DebugLocation(1, 28);
			mT__56(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// AbnfAst.g:1:34: T__57
			{
			DebugLocation(1, 34);
			mT__57(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// AbnfAst.g:1:40: T__58
			{
			DebugLocation(1, 40);
			mT__58(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// AbnfAst.g:1:46: T__59
			{
			DebugLocation(1, 46);
			mT__59(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// AbnfAst.g:1:52: T__60
			{
			DebugLocation(1, 52);
			mT__60(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// AbnfAst.g:1:58: COMMENT
			{
			DebugLocation(1, 58);
			mCOMMENT(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// AbnfAst.g:1:66: CHAR_VAL
			{
			DebugLocation(1, 66);
			mCHAR_VAL(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// AbnfAst.g:1:75: BIN_VAL_PREFIX
			{
			DebugLocation(1, 75);
			mBIN_VAL_PREFIX(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// AbnfAst.g:1:90: DEC_VAL_PREFIX
			{
			DebugLocation(1, 90);
			mDEC_VAL_PREFIX(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// AbnfAst.g:1:105: HEX_VAL_PREFIX
			{
			DebugLocation(1, 105);
			mHEX_VAL_PREFIX(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// AbnfAst.g:1:120: PROSE_VAL
			{
			DebugLocation(1, 120);
			mPROSE_VAL(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// AbnfAst.g:1:130: HEX_ALPHA
			{
			DebugLocation(1, 130);
			mHEX_ALPHA(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// AbnfAst.g:1:140: OTHER_ALPHA
			{
			DebugLocation(1, 140);
			mOTHER_ALPHA(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// AbnfAst.g:1:152: ASTERISK
			{
			DebugLocation(1, 152);
			mASTERISK(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// AbnfAst.g:1:161: DASH
			{
			DebugLocation(1, 161);
			mDASH(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// AbnfAst.g:1:166: CRLF
			{
			DebugLocation(1, 166);
			mCRLF(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// AbnfAst.g:1:171: ZERO
			{
			DebugLocation(1, 171);
			mZERO(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// AbnfAst.g:1:176: ONE
			{
			DebugLocation(1, 176);
			mONE(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// AbnfAst.g:1:180: OTHER_DIGIT
			{
			DebugLocation(1, 180);
			mOTHER_DIGIT(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// AbnfAst.g:1:192: WSP
			{
			DebugLocation(1, 192);
			mWSP(); 

			}
			break;

		}

	}


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

 
	#endregion

}
