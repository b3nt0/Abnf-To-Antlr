/*

    Copyright 2012-2013 Robert Pinchbeck
  
    This file is part of AbnfToAntlr.

    AbnfToAntlr is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    AbnfToAntlr is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with AbnfToAntlr.  If not, see <http://www.gnu.org/licenses/>.
  
*/

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 AbnfAst.g 2012-11-12 22:26:59

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
public partial class AbnfAstParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ALTERNATION_NODE", "ASTERISK", "BIN_VAL_CONCAT_NODE", "BIN_VAL_NODE", "BIN_VAL_NUMBER_NODE", "BIN_VAL_PREFIX", "BIN_VAL_RANGE_NODE", "CHAR_VAL", "CHAR_VAL_NODE", "COMMENT", "CONCATENATION_NODE", "CR", "CRLF", "DASH", "DEC_VAL_CONCAT_NODE", "DEC_VAL_NODE", "DEC_VAL_NUMBER_NODE", "DEC_VAL_PREFIX", "DEC_VAL_RANGE_NODE", "DQUOTE", "EXACT_OCCURENCES", "GROUP_NODE", "HEX_ALPHA", "HEX_VAL_CONCAT_NODE", "HEX_VAL_NODE", "HEX_VAL_NUMBER_NODE", "HEX_VAL_PREFIX", "HEX_VAL_RANGE_NODE", "HTAB", "LF", "NUMBER_NODE", "ONE", "ONE_OCCURENCE", "OPTION_NODE", "ORMORE_OCCURENCES", "OTHER_ALPHA", "OTHER_DIGIT", "PROSE_VAL", "PROSE_VAL_NODE", "REPEAT_NODE", "REPETITION_NODE", "RULE_LIST_NODE", "RULE_NAME_NODE", "RULE_NODE", "SP", "VCHAR", "WSP", "ZERO", "ZERO_OCCURENCES", "'('", "')'", "'.'", "'/'", "'='", "'=/'", "'['", "']'"
	};
	public const int EOF=-1;
	public const int ALTERNATION_NODE=4;
	public const int ASTERISK=5;
	public const int BIN_VAL_CONCAT_NODE=6;
	public const int BIN_VAL_NODE=7;
	public const int BIN_VAL_NUMBER_NODE=8;
	public const int BIN_VAL_PREFIX=9;
	public const int BIN_VAL_RANGE_NODE=10;
	public const int CHAR_VAL=11;
	public const int CHAR_VAL_NODE=12;
	public const int COMMENT=13;
	public const int CONCATENATION_NODE=14;
	public const int CR=15;
	public const int CRLF=16;
	public const int DASH=17;
	public const int DEC_VAL_CONCAT_NODE=18;
	public const int DEC_VAL_NODE=19;
	public const int DEC_VAL_NUMBER_NODE=20;
	public const int DEC_VAL_PREFIX=21;
	public const int DEC_VAL_RANGE_NODE=22;
	public const int DQUOTE=23;
	public const int EXACT_OCCURENCES=24;
	public const int GROUP_NODE=25;
	public const int HEX_ALPHA=26;
	public const int HEX_VAL_CONCAT_NODE=27;
	public const int HEX_VAL_NODE=28;
	public const int HEX_VAL_NUMBER_NODE=29;
	public const int HEX_VAL_PREFIX=30;
	public const int HEX_VAL_RANGE_NODE=31;
	public const int HTAB=32;
	public const int LF=33;
	public const int NUMBER_NODE=34;
	public const int ONE=35;
	public const int ONE_OCCURENCE=36;
	public const int OPTION_NODE=37;
	public const int ORMORE_OCCURENCES=38;
	public const int OTHER_ALPHA=39;
	public const int OTHER_DIGIT=40;
	public const int PROSE_VAL=41;
	public const int PROSE_VAL_NODE=42;
	public const int REPEAT_NODE=43;
	public const int REPETITION_NODE=44;
	public const int RULE_LIST_NODE=45;
	public const int RULE_NAME_NODE=46;
	public const int RULE_NODE=47;
	public const int SP=48;
	public const int VCHAR=49;
	public const int WSP=50;
	public const int ZERO=51;
	public const int ZERO_OCCURENCES=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;

	public AbnfAstParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public AbnfAstParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return AbnfAstParser.tokenNames; } }
	public override string GrammarFileName { get { return "AbnfAst.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_start();
	partial void LeaveRule_start();
	// $ANTLR start "start"
	// AbnfAst.g:77:8: public start : rulelist ;
	[GrammarRule("start")]
	public AstParserRuleReturnScope<CommonTree, IToken> start()
	{
		EnterRule_start();
		EnterRule("start", 1);
		TraceIn("start", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> rulelist1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "start");
		DebugLocation(77, 2);
		try
		{
			// AbnfAst.g:78:2: ( rulelist )
			DebugEnterAlt(1);
			// AbnfAst.g:79:3: rulelist
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(79, 3);
			PushFollow(Follow._rulelist_in_start166);
			rulelist1=rulelist();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, rulelist1.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("start", 1);
			LeaveRule("start", 1);
			LeaveRule_start();
		}
		DebugLocation(80, 2);
		} finally { DebugExitRule(GrammarFileName, "start"); }
		return retval;

	}
	// $ANTLR end "start"

	partial void EnterRule_rulelist();
	partial void LeaveRule_rulelist();
	// $ANTLR start "rulelist"
	// AbnfAst.g:82:1: rulelist : ( rule | ( ( c_wsp )* ( c_nl )=> c_nl ) )+ -> ^( RULE_LIST_NODE ( rule )+ ) ;
	[GrammarRule("rulelist")]
	private AstParserRuleReturnScope<CommonTree, IToken> rulelist()
	{
		EnterRule_rulelist();
		EnterRule("rulelist", 2);
		TraceIn("rulelist", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> rule2 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp3 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_nl4 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_rule=new RewriteRuleSubtreeStream(adaptor,"rule rule");
		RewriteRuleSubtreeStream stream_c_wsp=new RewriteRuleSubtreeStream(adaptor,"rule c_wsp");
		RewriteRuleSubtreeStream stream_c_nl=new RewriteRuleSubtreeStream(adaptor,"rule c_nl");
		try { DebugEnterRule(GrammarFileName, "rulelist");
		DebugLocation(82, 2);
		try
		{
			// AbnfAst.g:83:2: ( ( rule | ( ( c_wsp )* ( c_nl )=> c_nl ) )+ -> ^( RULE_LIST_NODE ( rule )+ ) )
			DebugEnterAlt(1);
			// AbnfAst.g:84:3: ( rule | ( ( c_wsp )* ( c_nl )=> c_nl ) )+
			{
			DebugLocation(84, 3);
			// AbnfAst.g:84:3: ( rule | ( ( c_wsp )* ( c_nl )=> c_nl ) )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=3;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==HEX_ALPHA||LA2_1==OTHER_ALPHA))
				{
					alt2 = 1;
				}
				else if ((LA2_1==COMMENT||LA2_1==CRLF||LA2_1==WSP))
				{
					alt2 = 2;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:84:5: rule
					{
					DebugLocation(84, 5);
					PushFollow(Follow._rule_in_rulelist182);
					rule2=rule();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_rule.Add(rule2.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AbnfAst.g:84:12: ( ( c_wsp )* ( c_nl )=> c_nl )
					{
					DebugLocation(84, 12);
					// AbnfAst.g:84:12: ( ( c_wsp )* ( c_nl )=> c_nl )
					DebugEnterAlt(1);
					// AbnfAst.g:84:13: ( c_wsp )* ( c_nl )=> c_nl
					{
					DebugLocation(84, 13);
					// AbnfAst.g:84:13: ( c_wsp )*
					try { DebugEnterSubRule(1);
					while (true)
					{
						int alt1=2;
						try { DebugEnterDecision(1, false);
						switch (input.LA(1))
						{
						case COMMENT:
							{
							int LA1_2 = input.LA(2);

							if ((LA1_2==WSP))
							{
								int LA1_3 = input.LA(3);

								if ((true))
								{
									alt1 = 1;
								}


							}


							}
							break;
						case CRLF:
							{
							int LA1_2 = input.LA(2);

							if ((LA1_2==WSP))
							{
								int LA1_3 = input.LA(3);

								if ((true))
								{
									alt1 = 1;
								}


							}


							}
							break;
						case WSP:
							{
							alt1 = 1;
							}
							break;
						}

						} finally { DebugExitDecision(1); }
						switch ( alt1 )
						{
						case 1:
							DebugEnterAlt(1);
							// AbnfAst.g:84:13: c_wsp
							{
							DebugLocation(84, 13);
							PushFollow(Follow._c_wsp_in_rulelist187);
							c_wsp3=c_wsp();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) stream_c_wsp.Add(c_wsp3.Tree);

							}
							break;

						default:
							goto loop1;
						}
					}

					loop1:
						;

					} finally { DebugExitSubRule(1); }

					DebugLocation(84, 28);
					PushFollow(Follow._c_nl_in_rulelist194);
					c_nl4=c_nl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_c_nl.Add(c_nl4.Tree);

					}


					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }



			{
			// AST REWRITE
			// elements: rule
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 84:37: -> ^( RULE_LIST_NODE ( rule )+ )
			{
				DebugLocation(84, 40);
				// AbnfAst.g:84:40: ^( RULE_LIST_NODE ( rule )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(84, 42);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(RULE_LIST_NODE, "RULE_LIST_NODE"), root_1);

				DebugLocation(84, 57);
				if (!(stream_rule.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_rule.HasNext )
				{
					DebugLocation(84, 57);
					adaptor.AddChild(root_1, stream_rule.NextTree());

				}
				stream_rule.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rulelist", 2);
			LeaveRule("rulelist", 2);
			LeaveRule_rulelist();
		}
		DebugLocation(85, 2);
		} finally { DebugExitRule(GrammarFileName, "rulelist"); }
		return retval;

	}
	// $ANTLR end "rulelist"

	partial void EnterRule_rule();
	partial void LeaveRule_rule();
	// $ANTLR start "rule"
	// AbnfAst.g:87:1: rule : rulename defined_as elements c_nl -> ^( RULE_NODE rulename elements ) ;
	[GrammarRule("rule")]
	private AstParserRuleReturnScope<CommonTree, IToken> rule()
	{
		EnterRule_rule();
		EnterRule("rule", 3);
		TraceIn("rule", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> rulename5 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> defined_as6 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elements7 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_nl8 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_rulename=new RewriteRuleSubtreeStream(adaptor,"rule rulename");
		RewriteRuleSubtreeStream stream_defined_as=new RewriteRuleSubtreeStream(adaptor,"rule defined_as");
		RewriteRuleSubtreeStream stream_elements=new RewriteRuleSubtreeStream(adaptor,"rule elements");
		RewriteRuleSubtreeStream stream_c_nl=new RewriteRuleSubtreeStream(adaptor,"rule c_nl");
		try { DebugEnterRule(GrammarFileName, "rule");
		DebugLocation(87, 2);
		try
		{
			// AbnfAst.g:88:2: ( rulename defined_as elements c_nl -> ^( RULE_NODE rulename elements ) )
			DebugEnterAlt(1);
			// AbnfAst.g:89:3: rulename defined_as elements c_nl
			{
			DebugLocation(89, 3);
			PushFollow(Follow._rulename_in_rule221);
			rulename5=rulename();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_rulename.Add(rulename5.Tree);
			DebugLocation(89, 12);
			PushFollow(Follow._defined_as_in_rule223);
			defined_as6=defined_as();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_defined_as.Add(defined_as6.Tree);
			DebugLocation(89, 23);
			PushFollow(Follow._elements_in_rule225);
			elements7=elements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_elements.Add(elements7.Tree);
			DebugLocation(89, 32);
			PushFollow(Follow._c_nl_in_rule227);
			c_nl8=c_nl();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_c_nl.Add(c_nl8.Tree);


			{
			// AST REWRITE
			// elements: rulename, elements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 89:37: -> ^( RULE_NODE rulename elements )
			{
				DebugLocation(89, 40);
				// AbnfAst.g:89:40: ^( RULE_NODE rulename elements )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(89, 42);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(RULE_NODE, "RULE_NODE"), root_1);

				DebugLocation(89, 52);
				adaptor.AddChild(root_1, stream_rulename.NextTree());
				DebugLocation(89, 61);
				adaptor.AddChild(root_1, stream_elements.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rule", 3);
			LeaveRule("rule", 3);
			LeaveRule_rule();
		}
		DebugLocation(92, 2);
		} finally { DebugExitRule(GrammarFileName, "rule"); }
		return retval;

	}
	// $ANTLR end "rule"

	partial void EnterRule_rulename();
	partial void LeaveRule_rulename();
	// $ANTLR start "rulename"
	// AbnfAst.g:94:1: rulename : rulechars -> ^( RULE_NAME_NODE rulechars ) ;
	[GrammarRule("rulename")]
	private AstParserRuleReturnScope<CommonTree, IToken> rulename()
	{
		EnterRule_rulename();
		EnterRule("rulename", 4);
		TraceIn("rulename", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> rulechars9 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_rulechars=new RewriteRuleSubtreeStream(adaptor,"rule rulechars");
		try { DebugEnterRule(GrammarFileName, "rulename");
		DebugLocation(94, 2);
		try
		{
			// AbnfAst.g:95:2: ( rulechars -> ^( RULE_NAME_NODE rulechars ) )
			DebugEnterAlt(1);
			// AbnfAst.g:96:3: rulechars
			{
			DebugLocation(96, 3);
			PushFollow(Follow._rulechars_in_rulename257);
			rulechars9=rulechars();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_rulechars.Add(rulechars9.Tree);


			{
			// AST REWRITE
			// elements: rulechars
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 96:13: -> ^( RULE_NAME_NODE rulechars )
			{
				DebugLocation(96, 16);
				// AbnfAst.g:96:16: ^( RULE_NAME_NODE rulechars )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(96, 18);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(RULE_NAME_NODE, "RULE_NAME_NODE"), root_1);

				DebugLocation(96, 33);
				adaptor.AddChild(root_1, stream_rulechars.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rulename", 4);
			LeaveRule("rulename", 4);
			LeaveRule_rulename();
		}
		DebugLocation(97, 2);
		} finally { DebugExitRule(GrammarFileName, "rulename"); }
		return retval;

	}
	// $ANTLR end "rulename"

	partial void EnterRule_rulechars();
	partial void LeaveRule_rulechars();
	// $ANTLR start "rulechars"
	// AbnfAst.g:99:1: rulechars : ( HEX_ALPHA | OTHER_ALPHA ) ( HEX_ALPHA | OTHER_ALPHA | ZERO | ONE | OTHER_DIGIT | DASH )* ;
	[GrammarRule("rulechars")]
	private AstParserRuleReturnScope<CommonTree, IToken> rulechars()
	{
		EnterRule_rulechars();
		EnterRule("rulechars", 5);
		TraceIn("rulechars", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set10 = default(IToken);
		IToken set11 = default(IToken);

		CommonTree set10_tree = default(CommonTree);
		CommonTree set11_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "rulechars");
		DebugLocation(99, 2);
		try
		{
			// AbnfAst.g:100:2: ( ( HEX_ALPHA | OTHER_ALPHA ) ( HEX_ALPHA | OTHER_ALPHA | ZERO | ONE | OTHER_DIGIT | DASH )* )
			DebugEnterAlt(1);
			// AbnfAst.g:101:3: ( HEX_ALPHA | OTHER_ALPHA ) ( HEX_ALPHA | OTHER_ALPHA | ZERO | ONE | OTHER_DIGIT | DASH )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(101, 3);

			set10=(IToken)input.LT(1);
			if (input.LA(1)==HEX_ALPHA||input.LA(1)==OTHER_ALPHA)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set10));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(101, 31);
			// AbnfAst.g:101:31: ( HEX_ALPHA | OTHER_ALPHA | ZERO | ONE | OTHER_DIGIT | DASH )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==DASH||LA3_1==HEX_ALPHA||LA3_1==ONE||(LA3_1>=OTHER_ALPHA && LA3_1<=OTHER_DIGIT)||LA3_1==ZERO))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:
					{
					DebugLocation(101, 31);

					set11=(IToken)input.LT(1);
					if (input.LA(1)==DASH||input.LA(1)==HEX_ALPHA||input.LA(1)==ONE||(input.LA(1)>=OTHER_ALPHA && input.LA(1)<=OTHER_DIGIT)||input.LA(1)==ZERO)
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set11));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rulechars", 5);
			LeaveRule("rulechars", 5);
			LeaveRule_rulechars();
		}
		DebugLocation(103, 2);
		} finally { DebugExitRule(GrammarFileName, "rulechars"); }
		return retval;

	}
	// $ANTLR end "rulechars"

	partial void EnterRule_defined_as();
	partial void LeaveRule_defined_as();
	// $ANTLR start "defined_as"
	// AbnfAst.g:105:1: defined_as : ( c_wsp )* ( '=' | '=/' ) ( c_wsp )* ;
	[GrammarRule("defined_as")]
	private AstParserRuleReturnScope<CommonTree, IToken> defined_as()
	{
		EnterRule_defined_as();
		EnterRule("defined_as", 6);
		TraceIn("defined_as", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set13 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp12 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp14 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set13_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "defined_as");
		DebugLocation(105, 2);
		try
		{
			// AbnfAst.g:106:2: ( ( c_wsp )* ( '=' | '=/' ) ( c_wsp )* )
			DebugEnterAlt(1);
			// AbnfAst.g:107:3: ( c_wsp )* ( '=' | '=/' ) ( c_wsp )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(107, 3);
			// AbnfAst.g:107:3: ( c_wsp )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==COMMENT||LA4_1==CRLF||LA4_1==WSP))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:107:3: c_wsp
					{
					DebugLocation(107, 3);
					PushFollow(Follow._c_wsp_in_defined_as331);
					c_wsp12=c_wsp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, c_wsp12.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(107, 10);

			set13=(IToken)input.LT(1);
			if ((input.LA(1)>=57 && input.LA(1)<=58))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set13));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(107, 25);
			// AbnfAst.g:107:25: ( c_wsp )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==COMMENT||LA5_1==CRLF||LA5_1==WSP))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:107:25: c_wsp
					{
					DebugLocation(107, 25);
					PushFollow(Follow._c_wsp_in_defined_as344);
					c_wsp14=c_wsp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, c_wsp14.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defined_as", 6);
			LeaveRule("defined_as", 6);
			LeaveRule_defined_as();
		}
		DebugLocation(110, 2);
		} finally { DebugExitRule(GrammarFileName, "defined_as"); }
		return retval;

	}
	// $ANTLR end "defined_as"

	partial void EnterRule_elements();
	partial void LeaveRule_elements();
	// $ANTLR start "elements"
	// AbnfAst.g:112:1: elements : alternation ( ( c_wsp )=> c_wsp )* -> alternation ;
	[GrammarRule("elements")]
	private AstParserRuleReturnScope<CommonTree, IToken> elements()
	{
		EnterRule_elements();
		EnterRule("elements", 7);
		TraceIn("elements", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> alternation15 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp16 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_alternation=new RewriteRuleSubtreeStream(adaptor,"rule alternation");
		RewriteRuleSubtreeStream stream_c_wsp=new RewriteRuleSubtreeStream(adaptor,"rule c_wsp");
		try { DebugEnterRule(GrammarFileName, "elements");
		DebugLocation(112, 2);
		try
		{
			// AbnfAst.g:113:2: ( alternation ( ( c_wsp )=> c_wsp )* -> alternation )
			DebugEnterAlt(1);
			// AbnfAst.g:114:3: alternation ( ( c_wsp )=> c_wsp )*
			{
			DebugLocation(114, 3);
			PushFollow(Follow._alternation_in_elements365);
			alternation15=alternation();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_alternation.Add(alternation15.Tree);
			DebugLocation(114, 15);
			// AbnfAst.g:114:15: ( ( c_wsp )=> c_wsp )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				try
				{
					alt6 = dfa6.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:114:16: ( c_wsp )=> c_wsp
					{
					DebugLocation(114, 25);
					PushFollow(Follow._c_wsp_in_elements372);
					c_wsp16=c_wsp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_c_wsp.Add(c_wsp16.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: alternation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 114:33: -> alternation
			{
				DebugLocation(114, 36);
				adaptor.AddChild(root_0, stream_alternation.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elements", 7);
			LeaveRule("elements", 7);
			LeaveRule_elements();
		}
		DebugLocation(115, 2);
		} finally { DebugExitRule(GrammarFileName, "elements"); }
		return retval;

	}
	// $ANTLR end "elements"

	partial void EnterRule_c_wsp();
	partial void LeaveRule_c_wsp();
	// $ANTLR start "c_wsp"
	// AbnfAst.g:117:1: c_wsp : ( WSP | ( c_nl WSP ) );
	[GrammarRule("c_wsp")]
	private AstParserRuleReturnScope<CommonTree, IToken> c_wsp()
	{
		EnterRule_c_wsp();
		EnterRule("c_wsp", 8);
		TraceIn("c_wsp", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WSP17 = default(IToken);
		IToken WSP19 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> c_nl18 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WSP17_tree = default(CommonTree);
		CommonTree WSP19_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "c_wsp");
		DebugLocation(117, 2);
		try
		{
			// AbnfAst.g:118:2: ( WSP | ( c_nl WSP ) )
			int alt7=2;
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==WSP))
			{
				alt7 = 1;
			}
			else if ((LA7_1==COMMENT||LA7_1==CRLF))
			{
				alt7 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// AbnfAst.g:119:3: WSP
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(119, 3);
				WSP17=(IToken)Match(input,WSP,Follow._WSP_in_c_wsp392); if (state.failed) return retval;
				if (state.backtracking == 0) {
				WSP17_tree = (CommonTree)adaptor.Create(WSP17);
				adaptor.AddChild(root_0, WSP17_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AbnfAst.g:119:9: ( c_nl WSP )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(119, 9);
				// AbnfAst.g:119:9: ( c_nl WSP )
				DebugEnterAlt(1);
				// AbnfAst.g:119:11: c_nl WSP
				{
				DebugLocation(119, 11);
				PushFollow(Follow._c_nl_in_c_wsp398);
				c_nl18=c_nl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, c_nl18.Tree);
				DebugLocation(119, 16);
				WSP19=(IToken)Match(input,WSP,Follow._WSP_in_c_wsp400); if (state.failed) return retval;
				if (state.backtracking == 0) {
				WSP19_tree = (CommonTree)adaptor.Create(WSP19);
				adaptor.AddChild(root_0, WSP19_tree);
				}

				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("c_wsp", 8);
			LeaveRule("c_wsp", 8);
			LeaveRule_c_wsp();
		}
		DebugLocation(120, 2);
		} finally { DebugExitRule(GrammarFileName, "c_wsp"); }
		return retval;

	}
	// $ANTLR end "c_wsp"

	partial void EnterRule_c_nl();
	partial void LeaveRule_c_nl();
	// $ANTLR start "c_nl"
	// AbnfAst.g:122:1: c_nl : ( comment | CRLF );
	[GrammarRule("c_nl")]
	private AstParserRuleReturnScope<CommonTree, IToken> c_nl()
	{
		EnterRule_c_nl();
		EnterRule("c_nl", 9);
		TraceIn("c_nl", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CRLF21 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> comment20 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CRLF21_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "c_nl");
		DebugLocation(122, 2);
		try
		{
			// AbnfAst.g:123:2: ( comment | CRLF )
			int alt8=2;
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==COMMENT))
			{
				alt8 = 1;
			}
			else if ((LA8_1==CRLF))
			{
				alt8 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// AbnfAst.g:124:3: comment
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(124, 3);
				PushFollow(Follow._comment_in_c_nl416);
				comment20=comment();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, comment20.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AbnfAst.g:124:13: CRLF
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(124, 13);
				CRLF21=(IToken)Match(input,CRLF,Follow._CRLF_in_c_nl420); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CRLF21_tree = (CommonTree)adaptor.Create(CRLF21);
				adaptor.AddChild(root_0, CRLF21_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("c_nl", 9);
			LeaveRule("c_nl", 9);
			LeaveRule_c_nl();
		}
		DebugLocation(126, 2);
		} finally { DebugExitRule(GrammarFileName, "c_nl"); }
		return retval;

	}
	// $ANTLR end "c_nl"

	partial void EnterRule_comment();
	partial void LeaveRule_comment();
	// $ANTLR start "comment"
	// AbnfAst.g:128:1: comment : COMMENT ;
	[GrammarRule("comment")]
	private AstParserRuleReturnScope<CommonTree, IToken> comment()
	{
		EnterRule_comment();
		EnterRule("comment", 10);
		TraceIn("comment", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COMMENT22 = default(IToken);

		CommonTree COMMENT22_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "comment");
		DebugLocation(128, 2);
		try
		{
			// AbnfAst.g:129:2: ( COMMENT )
			DebugEnterAlt(1);
			// AbnfAst.g:130:3: COMMENT
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(130, 3);
			COMMENT22=(IToken)Match(input,COMMENT,Follow._COMMENT_in_comment437); if (state.failed) return retval;
			if (state.backtracking == 0) {
			COMMENT22_tree = (CommonTree)adaptor.Create(COMMENT22);
			adaptor.AddChild(root_0, COMMENT22_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("comment", 10);
			LeaveRule("comment", 10);
			LeaveRule_comment();
		}
		DebugLocation(131, 2);
		} finally { DebugExitRule(GrammarFileName, "comment"); }
		return retval;

	}
	// $ANTLR end "comment"

	partial void EnterRule_alternation();
	partial void LeaveRule_alternation();
	// $ANTLR start "alternation"
	// AbnfAst.g:133:1: alternation : concatenation ( ( c_wsp )* '/' ( c_wsp )* concatenation )* -> ^( ALTERNATION_NODE ( concatenation )+ ) ;
	[GrammarRule("alternation")]
	private AstParserRuleReturnScope<CommonTree, IToken> alternation()
	{
		EnterRule_alternation();
		EnterRule("alternation", 11);
		TraceIn("alternation", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal25 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> concatenation23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp24 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp26 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> concatenation27 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal25_tree = default(CommonTree);
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleSubtreeStream stream_concatenation=new RewriteRuleSubtreeStream(adaptor,"rule concatenation");
		RewriteRuleSubtreeStream stream_c_wsp=new RewriteRuleSubtreeStream(adaptor,"rule c_wsp");
		try { DebugEnterRule(GrammarFileName, "alternation");
		DebugLocation(133, 2);
		try
		{
			// AbnfAst.g:134:2: ( concatenation ( ( c_wsp )* '/' ( c_wsp )* concatenation )* -> ^( ALTERNATION_NODE ( concatenation )+ ) )
			DebugEnterAlt(1);
			// AbnfAst.g:135:3: concatenation ( ( c_wsp )* '/' ( c_wsp )* concatenation )*
			{
			DebugLocation(135, 3);
			PushFollow(Follow._concatenation_in_alternation451);
			concatenation23=concatenation();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_concatenation.Add(concatenation23.Tree);
			DebugLocation(135, 17);
			// AbnfAst.g:135:17: ( ( c_wsp )* '/' ( c_wsp )* concatenation )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				try
				{
					alt11 = dfa11.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:135:19: ( c_wsp )* '/' ( c_wsp )* concatenation
					{
					DebugLocation(135, 19);
					// AbnfAst.g:135:19: ( c_wsp )*
					try { DebugEnterSubRule(9);
					while (true)
					{
						int alt9=2;
						try { DebugEnterDecision(9, false);
						int LA9_1 = input.LA(1);

						if ((LA9_1==COMMENT||LA9_1==CRLF||LA9_1==WSP))
						{
							alt9 = 1;
						}


						} finally { DebugExitDecision(9); }
						switch ( alt9 )
						{
						case 1:
							DebugEnterAlt(1);
							// AbnfAst.g:135:19: c_wsp
							{
							DebugLocation(135, 19);
							PushFollow(Follow._c_wsp_in_alternation455);
							c_wsp24=c_wsp();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) stream_c_wsp.Add(c_wsp24.Tree);

							}
							break;

						default:
							goto loop9;
						}
					}

					loop9:
						;

					} finally { DebugExitSubRule(9); }

					DebugLocation(135, 26);
					char_literal25=(IToken)Match(input,56,Follow._56_in_alternation458); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_56.Add(char_literal25);

					DebugLocation(135, 30);
					// AbnfAst.g:135:30: ( c_wsp )*
					try { DebugEnterSubRule(10);
					while (true)
					{
						int alt10=2;
						try { DebugEnterDecision(10, false);
						int LA10_1 = input.LA(1);

						if ((LA10_1==COMMENT||LA10_1==CRLF||LA10_1==WSP))
						{
							alt10 = 1;
						}


						} finally { DebugExitDecision(10); }
						switch ( alt10 )
						{
						case 1:
							DebugEnterAlt(1);
							// AbnfAst.g:135:30: c_wsp
							{
							DebugLocation(135, 30);
							PushFollow(Follow._c_wsp_in_alternation460);
							c_wsp26=c_wsp();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) stream_c_wsp.Add(c_wsp26.Tree);

							}
							break;

						default:
							goto loop10;
						}
					}

					loop10:
						;

					} finally { DebugExitSubRule(10); }

					DebugLocation(135, 37);
					PushFollow(Follow._concatenation_in_alternation463);
					concatenation27=concatenation();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_concatenation.Add(concatenation27.Tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }



			{
			// AST REWRITE
			// elements: concatenation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 135:54: -> ^( ALTERNATION_NODE ( concatenation )+ )
			{
				DebugLocation(135, 57);
				// AbnfAst.g:135:57: ^( ALTERNATION_NODE ( concatenation )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(135, 59);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ALTERNATION_NODE, "ALTERNATION_NODE"), root_1);

				DebugLocation(135, 76);
				if (!(stream_concatenation.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_concatenation.HasNext )
				{
					DebugLocation(135, 76);
					adaptor.AddChild(root_1, stream_concatenation.NextTree());

				}
				stream_concatenation.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("alternation", 11);
			LeaveRule("alternation", 11);
			LeaveRule_alternation();
		}
		DebugLocation(136, 2);
		} finally { DebugExitRule(GrammarFileName, "alternation"); }
		return retval;

	}
	// $ANTLR end "alternation"

	partial void EnterRule_concatenation();
	partial void LeaveRule_concatenation();
	// $ANTLR start "concatenation"
	// AbnfAst.g:138:1: concatenation : repetition ( ( c_wsp )+ repetition )* -> ^( CONCATENATION_NODE ( repetition )+ ) ;
	[GrammarRule("concatenation")]
	private AstParserRuleReturnScope<CommonTree, IToken> concatenation()
	{
		EnterRule_concatenation();
		EnterRule("concatenation", 12);
		TraceIn("concatenation", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> repetition28 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp29 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> repetition30 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_repetition=new RewriteRuleSubtreeStream(adaptor,"rule repetition");
		RewriteRuleSubtreeStream stream_c_wsp=new RewriteRuleSubtreeStream(adaptor,"rule c_wsp");
		try { DebugEnterRule(GrammarFileName, "concatenation");
		DebugLocation(138, 2);
		try
		{
			// AbnfAst.g:139:2: ( repetition ( ( c_wsp )+ repetition )* -> ^( CONCATENATION_NODE ( repetition )+ ) )
			DebugEnterAlt(1);
			// AbnfAst.g:140:3: repetition ( ( c_wsp )+ repetition )*
			{
			DebugLocation(140, 3);
			PushFollow(Follow._repetition_in_concatenation489);
			repetition28=repetition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_repetition.Add(repetition28.Tree);
			DebugLocation(140, 14);
			// AbnfAst.g:140:14: ( ( c_wsp )+ repetition )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				try
				{
					alt13 = dfa13.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:140:16: ( c_wsp )+ repetition
					{
					DebugLocation(140, 16);
					// AbnfAst.g:140:16: ( c_wsp )+
					int cnt12=0;
					try { DebugEnterSubRule(12);
					while (true)
					{
						int alt12=2;
						try { DebugEnterDecision(12, false);
						int LA12_1 = input.LA(1);

						if ((LA12_1==COMMENT||LA12_1==CRLF||LA12_1==WSP))
						{
							alt12 = 1;
						}


						} finally { DebugExitDecision(12); }
						switch (alt12)
						{
						case 1:
							DebugEnterAlt(1);
							// AbnfAst.g:140:16: c_wsp
							{
							DebugLocation(140, 16);
							PushFollow(Follow._c_wsp_in_concatenation493);
							c_wsp29=c_wsp();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) stream_c_wsp.Add(c_wsp29.Tree);

							}
							break;

						default:
							if (cnt12 >= 1)
								goto loop12;

							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee12 = new EarlyExitException( 12, input );
							DebugRecognitionException(eee12);
							throw eee12;
						}
						cnt12++;
					}
					loop12:
						;

					} finally { DebugExitSubRule(12); }

					DebugLocation(140, 23);
					PushFollow(Follow._repetition_in_concatenation496);
					repetition30=repetition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_repetition.Add(repetition30.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }



			{
			// AST REWRITE
			// elements: repetition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 140:37: -> ^( CONCATENATION_NODE ( repetition )+ )
			{
				DebugLocation(140, 40);
				// AbnfAst.g:140:40: ^( CONCATENATION_NODE ( repetition )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(140, 42);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONCATENATION_NODE, "CONCATENATION_NODE"), root_1);

				DebugLocation(140, 61);
				if (!(stream_repetition.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_repetition.HasNext )
				{
					DebugLocation(140, 61);
					adaptor.AddChild(root_1, stream_repetition.NextTree());

				}
				stream_repetition.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concatenation", 12);
			LeaveRule("concatenation", 12);
			LeaveRule_concatenation();
		}
		DebugLocation(141, 2);
		} finally { DebugExitRule(GrammarFileName, "concatenation"); }
		return retval;

	}
	// $ANTLR end "concatenation"

	partial void EnterRule_repetition();
	partial void LeaveRule_repetition();
	// $ANTLR start "repetition"
	// AbnfAst.g:143:1: repetition : ( ASTERISK number element -> ^( REPETITION_NODE element ZERO_OCCURENCES number ) |min= number ASTERISK max= number element -> ^( REPETITION_NODE element $min $max) | number ASTERISK element -> ^( REPETITION_NODE element number ORMORE_OCCURENCES ) | ASTERISK element -> ^( REPETITION_NODE element ZERO_OCCURENCES ORMORE_OCCURENCES ) | number element -> ^( REPETITION_NODE element number EXACT_OCCURENCES ) | element -> ^( REPETITION_NODE element ONE_OCCURENCE EXACT_OCCURENCES ) );
	[GrammarRule("repetition")]
	private AstParserRuleReturnScope<CommonTree, IToken> repetition()
	{
		EnterRule_repetition();
		EnterRule("repetition", 13);
		TraceIn("repetition", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ASTERISK31 = default(IToken);
		IToken ASTERISK34 = default(IToken);
		IToken ASTERISK37 = default(IToken);
		IToken ASTERISK39 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> min = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> max = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> number32 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> element33 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> element35 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> number36 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> element38 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> element40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> number41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> element42 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> element43 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ASTERISK31_tree = default(CommonTree);
		CommonTree ASTERISK34_tree = default(CommonTree);
		CommonTree ASTERISK37_tree = default(CommonTree);
		CommonTree ASTERISK39_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ASTERISK=new RewriteRuleITokenStream(adaptor,"token ASTERISK");
		RewriteRuleSubtreeStream stream_number=new RewriteRuleSubtreeStream(adaptor,"rule number");
		RewriteRuleSubtreeStream stream_element=new RewriteRuleSubtreeStream(adaptor,"rule element");
		try { DebugEnterRule(GrammarFileName, "repetition");
		DebugLocation(143, 2);
		try
		{
			// AbnfAst.g:144:2: ( ASTERISK number element -> ^( REPETITION_NODE element ZERO_OCCURENCES number ) |min= number ASTERISK max= number element -> ^( REPETITION_NODE element $min $max) | number ASTERISK element -> ^( REPETITION_NODE element number ORMORE_OCCURENCES ) | ASTERISK element -> ^( REPETITION_NODE element ZERO_OCCURENCES ORMORE_OCCURENCES ) | number element -> ^( REPETITION_NODE element number EXACT_OCCURENCES ) | element -> ^( REPETITION_NODE element ONE_OCCURENCE EXACT_OCCURENCES ) )
			int alt14=6;
			try { DebugEnterDecision(14, false);
			try
			{
				alt14 = dfa14.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// AbnfAst.g:145:3: ASTERISK number element
				{
				DebugLocation(145, 3);
				ASTERISK31=(IToken)Match(input,ASTERISK,Follow._ASTERISK_in_repetition522); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASTERISK.Add(ASTERISK31);

				DebugLocation(145, 12);
				PushFollow(Follow._number_in_repetition524);
				number32=number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_number.Add(number32.Tree);
				DebugLocation(145, 19);
				PushFollow(Follow._element_in_repetition526);
				element33=element();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_element.Add(element33.Tree);


				{
				// AST REWRITE
				// elements: element, number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 145:44: -> ^( REPETITION_NODE element ZERO_OCCURENCES number )
				{
					DebugLocation(145, 47);
					// AbnfAst.g:145:47: ^( REPETITION_NODE element ZERO_OCCURENCES number )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(145, 49);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REPETITION_NODE, "REPETITION_NODE"), root_1);

					DebugLocation(145, 65);
					adaptor.AddChild(root_1, stream_element.NextTree());
					DebugLocation(145, 73);
					adaptor.AddChild(root_1, (CommonTree)adaptor.Create(ZERO_OCCURENCES, "ZERO_OCCURENCES"));
					DebugLocation(145, 89);
					adaptor.AddChild(root_1, stream_number.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AbnfAst.g:146:5: min= number ASTERISK max= number element
				{
				DebugLocation(146, 8);
				PushFollow(Follow._number_in_repetition563);
				min=number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_number.Add(min.Tree);
				DebugLocation(146, 16);
				ASTERISK34=(IToken)Match(input,ASTERISK,Follow._ASTERISK_in_repetition565); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASTERISK.Add(ASTERISK34);

				DebugLocation(146, 28);
				PushFollow(Follow._number_in_repetition569);
				max=number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_number.Add(max.Tree);
				DebugLocation(146, 36);
				PushFollow(Follow._element_in_repetition571);
				element35=element();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_element.Add(element35.Tree);


				{
				// AST REWRITE
				// elements: element, min, max
				// token labels: 
				// rule labels: min, max, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_min=new RewriteRuleSubtreeStream(adaptor,"rule min",min!=null?min.Tree:null);
				RewriteRuleSubtreeStream stream_max=new RewriteRuleSubtreeStream(adaptor,"rule max",max!=null?max.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 146:44: -> ^( REPETITION_NODE element $min $max)
				{
					DebugLocation(146, 47);
					// AbnfAst.g:146:47: ^( REPETITION_NODE element $min $max)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(146, 49);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REPETITION_NODE, "REPETITION_NODE"), root_1);

					DebugLocation(146, 65);
					adaptor.AddChild(root_1, stream_element.NextTree());
					DebugLocation(146, 74);
					adaptor.AddChild(root_1, stream_min.NextTree());
					DebugLocation(146, 79);
					adaptor.AddChild(root_1, stream_max.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AbnfAst.g:147:5: number ASTERISK element
				{
				DebugLocation(147, 5);
				PushFollow(Follow._number_in_repetition591);
				number36=number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_number.Add(number36.Tree);
				DebugLocation(147, 12);
				ASTERISK37=(IToken)Match(input,ASTERISK,Follow._ASTERISK_in_repetition593); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASTERISK.Add(ASTERISK37);

				DebugLocation(147, 21);
				PushFollow(Follow._element_in_repetition595);
				element38=element();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_element.Add(element38.Tree);


				{
				// AST REWRITE
				// elements: element, number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 147:44: -> ^( REPETITION_NODE element number ORMORE_OCCURENCES )
				{
					DebugLocation(147, 47);
					// AbnfAst.g:147:47: ^( REPETITION_NODE element number ORMORE_OCCURENCES )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(147, 49);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REPETITION_NODE, "REPETITION_NODE"), root_1);

					DebugLocation(147, 65);
					adaptor.AddChild(root_1, stream_element.NextTree());
					DebugLocation(147, 73);
					adaptor.AddChild(root_1, stream_number.NextTree());
					DebugLocation(147, 80);
					adaptor.AddChild(root_1, (CommonTree)adaptor.Create(ORMORE_OCCURENCES, "ORMORE_OCCURENCES"));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AbnfAst.g:148:5: ASTERISK element
				{
				DebugLocation(148, 5);
				ASTERISK39=(IToken)Match(input,ASTERISK,Follow._ASTERISK_in_repetition628); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASTERISK.Add(ASTERISK39);

				DebugLocation(148, 14);
				PushFollow(Follow._element_in_repetition630);
				element40=element();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_element.Add(element40.Tree);


				{
				// AST REWRITE
				// elements: element
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 148:44: -> ^( REPETITION_NODE element ZERO_OCCURENCES ORMORE_OCCURENCES )
				{
					DebugLocation(148, 47);
					// AbnfAst.g:148:47: ^( REPETITION_NODE element ZERO_OCCURENCES ORMORE_OCCURENCES )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(148, 49);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REPETITION_NODE, "REPETITION_NODE"), root_1);

					DebugLocation(148, 65);
					adaptor.AddChild(root_1, stream_element.NextTree());
					DebugLocation(148, 73);
					adaptor.AddChild(root_1, (CommonTree)adaptor.Create(ZERO_OCCURENCES, "ZERO_OCCURENCES"));
					DebugLocation(148, 89);
					adaptor.AddChild(root_1, (CommonTree)adaptor.Create(ORMORE_OCCURENCES, "ORMORE_OCCURENCES"));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AbnfAst.g:149:5: number element
				{
				DebugLocation(149, 5);
				PushFollow(Follow._number_in_repetition670);
				number41=number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_number.Add(number41.Tree);
				DebugLocation(149, 12);
				PushFollow(Follow._element_in_repetition672);
				element42=element();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_element.Add(element42.Tree);


				{
				// AST REWRITE
				// elements: element, number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 149:44: -> ^( REPETITION_NODE element number EXACT_OCCURENCES )
				{
					DebugLocation(149, 47);
					// AbnfAst.g:149:47: ^( REPETITION_NODE element number EXACT_OCCURENCES )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(149, 49);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REPETITION_NODE, "REPETITION_NODE"), root_1);

					DebugLocation(149, 65);
					adaptor.AddChild(root_1, stream_element.NextTree());
					DebugLocation(149, 73);
					adaptor.AddChild(root_1, stream_number.NextTree());
					DebugLocation(149, 80);
					adaptor.AddChild(root_1, (CommonTree)adaptor.Create(EXACT_OCCURENCES, "EXACT_OCCURENCES"));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AbnfAst.g:150:5: element
				{
				DebugLocation(150, 5);
				PushFollow(Follow._element_in_repetition714);
				element43=element();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_element.Add(element43.Tree);


				{
				// AST REWRITE
				// elements: element
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 150:44: -> ^( REPETITION_NODE element ONE_OCCURENCE EXACT_OCCURENCES )
				{
					DebugLocation(150, 47);
					// AbnfAst.g:150:47: ^( REPETITION_NODE element ONE_OCCURENCE EXACT_OCCURENCES )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(150, 49);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REPETITION_NODE, "REPETITION_NODE"), root_1);

					DebugLocation(150, 65);
					adaptor.AddChild(root_1, stream_element.NextTree());
					DebugLocation(150, 73);
					adaptor.AddChild(root_1, (CommonTree)adaptor.Create(ONE_OCCURENCE, "ONE_OCCURENCE"));
					DebugLocation(150, 87);
					adaptor.AddChild(root_1, (CommonTree)adaptor.Create(EXACT_OCCURENCES, "EXACT_OCCURENCES"));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("repetition", 13);
			LeaveRule("repetition", 13);
			LeaveRule_repetition();
		}
		DebugLocation(151, 2);
		} finally { DebugExitRule(GrammarFileName, "repetition"); }
		return retval;

	}
	// $ANTLR end "repetition"

	partial void EnterRule_number();
	partial void LeaveRule_number();
	// $ANTLR start "number"
	// AbnfAst.g:153:1: number : number_val -> ^( NUMBER_NODE number_val ) ;
	[GrammarRule("number")]
	private AstParserRuleReturnScope<CommonTree, IToken> number()
	{
		EnterRule_number();
		EnterRule("number", 14);
		TraceIn("number", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> number_val44 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_number_val=new RewriteRuleSubtreeStream(adaptor,"rule number_val");
		try { DebugEnterRule(GrammarFileName, "number");
		DebugLocation(153, 2);
		try
		{
			// AbnfAst.g:154:2: ( number_val -> ^( NUMBER_NODE number_val ) )
			DebugEnterAlt(1);
			// AbnfAst.g:155:3: number_val
			{
			DebugLocation(155, 3);
			PushFollow(Follow._number_val_in_number771);
			number_val44=number_val();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_number_val.Add(number_val44.Tree);


			{
			// AST REWRITE
			// elements: number_val
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 155:14: -> ^( NUMBER_NODE number_val )
			{
				DebugLocation(155, 17);
				// AbnfAst.g:155:17: ^( NUMBER_NODE number_val )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(155, 19);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NUMBER_NODE, "NUMBER_NODE"), root_1);

				DebugLocation(155, 31);
				adaptor.AddChild(root_1, stream_number_val.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("number", 14);
			LeaveRule("number", 14);
			LeaveRule_number();
		}
		DebugLocation(156, 2);
		} finally { DebugExitRule(GrammarFileName, "number"); }
		return retval;

	}
	// $ANTLR end "number"

	partial void EnterRule_number_val();
	partial void LeaveRule_number_val();
	// $ANTLR start "number_val"
	// AbnfAst.g:158:1: number_val : ( ZERO | ONE | OTHER_DIGIT )+ ;
	[GrammarRule("number_val")]
	private AstParserRuleReturnScope<CommonTree, IToken> number_val()
	{
		EnterRule_number_val();
		EnterRule("number_val", 15);
		TraceIn("number_val", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set45 = default(IToken);

		CommonTree set45_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "number_val");
		DebugLocation(158, 2);
		try
		{
			// AbnfAst.g:159:2: ( ( ZERO | ONE | OTHER_DIGIT )+ )
			DebugEnterAlt(1);
			// AbnfAst.g:160:3: ( ZERO | ONE | OTHER_DIGIT )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(160, 3);
			// AbnfAst.g:160:3: ( ZERO | ONE | OTHER_DIGIT )+
			int cnt15=0;
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==ONE||LA15_1==OTHER_DIGIT||LA15_1==ZERO))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:
					{
					DebugLocation(160, 3);

					set45=(IToken)input.LT(1);
					if (input.LA(1)==ONE||input.LA(1)==OTHER_DIGIT||input.LA(1)==ZERO)
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set45));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					if (cnt15 >= 1)
						goto loop15;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee15 = new EarlyExitException( 15, input );
					DebugRecognitionException(eee15);
					throw eee15;
				}
				cnt15++;
			}
			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("number_val", 15);
			LeaveRule("number_val", 15);
			LeaveRule_number_val();
		}
		DebugLocation(162, 2);
		} finally { DebugExitRule(GrammarFileName, "number_val"); }
		return retval;

	}
	// $ANTLR end "number_val"

	partial void EnterRule_element();
	partial void LeaveRule_element();
	// $ANTLR start "element"
	// AbnfAst.g:164:1: element : ( rulename | group | option | char_val | num_val | prose_val );
	[GrammarRule("element")]
	private AstParserRuleReturnScope<CommonTree, IToken> element()
	{
		EnterRule_element();
		EnterRule("element", 16);
		TraceIn("element", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> rulename46 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group47 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> option48 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> char_val49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> num_val50 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> prose_val51 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "element");
		DebugLocation(164, 2);
		try
		{
			// AbnfAst.g:165:2: ( rulename | group | option | char_val | num_val | prose_val )
			int alt16=6;
			try { DebugEnterDecision(16, false);
			switch (input.LA(1))
			{
			case HEX_ALPHA:
			case OTHER_ALPHA:
				{
				alt16 = 1;
				}
				break;
			case 53:
				{
				alt16 = 2;
				}
				break;
			case 59:
				{
				alt16 = 3;
				}
				break;
			case CHAR_VAL:
				{
				alt16 = 4;
				}
				break;
			case BIN_VAL_PREFIX:
			case DEC_VAL_PREFIX:
			case HEX_VAL_PREFIX:
				{
				alt16 = 5;
				}
				break;
			case PROSE_VAL:
				{
				alt16 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// AbnfAst.g:166:3: rulename
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(166, 3);
				PushFollow(Follow._rulename_in_element823);
				rulename46=rulename();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, rulename46.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AbnfAst.g:167:5: group
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(167, 5);
				PushFollow(Follow._group_in_element829);
				group47=group();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group47.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AbnfAst.g:168:5: option
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(168, 5);
				PushFollow(Follow._option_in_element835);
				option48=option();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, option48.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AbnfAst.g:169:5: char_val
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(169, 5);
				PushFollow(Follow._char_val_in_element841);
				char_val49=char_val();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, char_val49.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AbnfAst.g:170:5: num_val
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(170, 5);
				PushFollow(Follow._num_val_in_element847);
				num_val50=num_val();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, num_val50.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AbnfAst.g:171:5: prose_val
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(171, 5);
				PushFollow(Follow._prose_val_in_element853);
				prose_val51=prose_val();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, prose_val51.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("element", 16);
			LeaveRule("element", 16);
			LeaveRule_element();
		}
		DebugLocation(172, 2);
		} finally { DebugExitRule(GrammarFileName, "element"); }
		return retval;

	}
	// $ANTLR end "element"

	partial void EnterRule_group();
	partial void LeaveRule_group();
	// $ANTLR start "group"
	// AbnfAst.g:174:1: group : '(' ( c_wsp )* alternation ( c_wsp )* ')' -> ^( GROUP_NODE alternation ) ;
	[GrammarRule("group")]
	private AstParserRuleReturnScope<CommonTree, IToken> group()
	{
		EnterRule_group();
		EnterRule("group", 17);
		TraceIn("group", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal52 = default(IToken);
		IToken char_literal56 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp53 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> alternation54 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp55 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal52_tree = default(CommonTree);
		CommonTree char_literal56_tree = default(CommonTree);
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleSubtreeStream stream_c_wsp=new RewriteRuleSubtreeStream(adaptor,"rule c_wsp");
		RewriteRuleSubtreeStream stream_alternation=new RewriteRuleSubtreeStream(adaptor,"rule alternation");
		try { DebugEnterRule(GrammarFileName, "group");
		DebugLocation(174, 2);
		try
		{
			// AbnfAst.g:175:2: ( '(' ( c_wsp )* alternation ( c_wsp )* ')' -> ^( GROUP_NODE alternation ) )
			DebugEnterAlt(1);
			// AbnfAst.g:176:3: '(' ( c_wsp )* alternation ( c_wsp )* ')'
			{
			DebugLocation(176, 3);
			char_literal52=(IToken)Match(input,53,Follow._53_in_group867); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_53.Add(char_literal52);

			DebugLocation(176, 7);
			// AbnfAst.g:176:7: ( c_wsp )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==COMMENT||LA17_1==CRLF||LA17_1==WSP))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:176:7: c_wsp
					{
					DebugLocation(176, 7);
					PushFollow(Follow._c_wsp_in_group869);
					c_wsp53=c_wsp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_c_wsp.Add(c_wsp53.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(176, 14);
			PushFollow(Follow._alternation_in_group872);
			alternation54=alternation();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_alternation.Add(alternation54.Tree);
			DebugLocation(176, 26);
			// AbnfAst.g:176:26: ( c_wsp )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==COMMENT||LA18_1==CRLF||LA18_1==WSP))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:176:26: c_wsp
					{
					DebugLocation(176, 26);
					PushFollow(Follow._c_wsp_in_group874);
					c_wsp55=c_wsp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_c_wsp.Add(c_wsp55.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(176, 33);
			char_literal56=(IToken)Match(input,54,Follow._54_in_group877); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_54.Add(char_literal56);



			{
			// AST REWRITE
			// elements: alternation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 176:37: -> ^( GROUP_NODE alternation )
			{
				DebugLocation(176, 40);
				// AbnfAst.g:176:40: ^( GROUP_NODE alternation )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(176, 42);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(GROUP_NODE, "GROUP_NODE"), root_1);

				DebugLocation(176, 53);
				adaptor.AddChild(root_1, stream_alternation.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("group", 17);
			LeaveRule("group", 17);
			LeaveRule_group();
		}
		DebugLocation(177, 2);
		} finally { DebugExitRule(GrammarFileName, "group"); }
		return retval;

	}
	// $ANTLR end "group"

	partial void EnterRule_option();
	partial void LeaveRule_option();
	// $ANTLR start "option"
	// AbnfAst.g:179:1: option : '[' ( c_wsp )* alternation ( c_wsp )* ']' -> ^( OPTION_NODE alternation ) ;
	[GrammarRule("option")]
	private AstParserRuleReturnScope<CommonTree, IToken> option()
	{
		EnterRule_option();
		EnterRule("option", 18);
		TraceIn("option", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal57 = default(IToken);
		IToken char_literal61 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp58 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> alternation59 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> c_wsp60 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal57_tree = default(CommonTree);
		CommonTree char_literal61_tree = default(CommonTree);
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleSubtreeStream stream_c_wsp=new RewriteRuleSubtreeStream(adaptor,"rule c_wsp");
		RewriteRuleSubtreeStream stream_alternation=new RewriteRuleSubtreeStream(adaptor,"rule alternation");
		try { DebugEnterRule(GrammarFileName, "option");
		DebugLocation(179, 2);
		try
		{
			// AbnfAst.g:180:2: ( '[' ( c_wsp )* alternation ( c_wsp )* ']' -> ^( OPTION_NODE alternation ) )
			DebugEnterAlt(1);
			// AbnfAst.g:181:3: '[' ( c_wsp )* alternation ( c_wsp )* ']'
			{
			DebugLocation(181, 3);
			char_literal57=(IToken)Match(input,59,Follow._59_in_option899); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_59.Add(char_literal57);

			DebugLocation(181, 7);
			// AbnfAst.g:181:7: ( c_wsp )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==COMMENT||LA19_1==CRLF||LA19_1==WSP))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:181:7: c_wsp
					{
					DebugLocation(181, 7);
					PushFollow(Follow._c_wsp_in_option901);
					c_wsp58=c_wsp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_c_wsp.Add(c_wsp58.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(181, 14);
			PushFollow(Follow._alternation_in_option904);
			alternation59=alternation();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_alternation.Add(alternation59.Tree);
			DebugLocation(181, 26);
			// AbnfAst.g:181:26: ( c_wsp )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==COMMENT||LA20_1==CRLF||LA20_1==WSP))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:181:26: c_wsp
					{
					DebugLocation(181, 26);
					PushFollow(Follow._c_wsp_in_option906);
					c_wsp60=c_wsp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_c_wsp.Add(c_wsp60.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(181, 33);
			char_literal61=(IToken)Match(input,60,Follow._60_in_option909); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_60.Add(char_literal61);



			{
			// AST REWRITE
			// elements: alternation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 181:37: -> ^( OPTION_NODE alternation )
			{
				DebugLocation(181, 40);
				// AbnfAst.g:181:40: ^( OPTION_NODE alternation )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(181, 42);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(OPTION_NODE, "OPTION_NODE"), root_1);

				DebugLocation(181, 54);
				adaptor.AddChild(root_1, stream_alternation.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("option", 18);
			LeaveRule("option", 18);
			LeaveRule_option();
		}
		DebugLocation(182, 2);
		} finally { DebugExitRule(GrammarFileName, "option"); }
		return retval;

	}
	// $ANTLR end "option"

	partial void EnterRule_num_val();
	partial void LeaveRule_num_val();
	// $ANTLR start "num_val"
	// AbnfAst.g:184:1: num_val : ( bin_val | dec_val | hex_val ) ;
	[GrammarRule("num_val")]
	private AstParserRuleReturnScope<CommonTree, IToken> num_val()
	{
		EnterRule_num_val();
		EnterRule("num_val", 19);
		TraceIn("num_val", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> bin_val62 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dec_val63 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> hex_val64 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "num_val");
		DebugLocation(184, 2);
		try
		{
			// AbnfAst.g:185:2: ( ( bin_val | dec_val | hex_val ) )
			DebugEnterAlt(1);
			// AbnfAst.g:186:3: ( bin_val | dec_val | hex_val )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(186, 3);
			// AbnfAst.g:186:3: ( bin_val | dec_val | hex_val )
			int alt21=3;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case BIN_VAL_PREFIX:
				{
				alt21 = 1;
				}
				break;
			case DEC_VAL_PREFIX:
				{
				alt21 = 2;
				}
				break;
			case HEX_VAL_PREFIX:
				{
				alt21 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// AbnfAst.g:186:5: bin_val
				{
				DebugLocation(186, 5);
				PushFollow(Follow._bin_val_in_num_val933);
				bin_val62=bin_val();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, bin_val62.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AbnfAst.g:186:15: dec_val
				{
				DebugLocation(186, 15);
				PushFollow(Follow._dec_val_in_num_val937);
				dec_val63=dec_val();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, dec_val63.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AbnfAst.g:186:25: hex_val
				{
				DebugLocation(186, 25);
				PushFollow(Follow._hex_val_in_num_val941);
				hex_val64=hex_val();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, hex_val64.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("num_val", 19);
			LeaveRule("num_val", 19);
			LeaveRule_num_val();
		}
		DebugLocation(187, 2);
		} finally { DebugExitRule(GrammarFileName, "num_val"); }
		return retval;

	}
	// $ANTLR end "num_val"

	partial void EnterRule_char_val();
	partial void LeaveRule_char_val();
	// $ANTLR start "char_val"
	// AbnfAst.g:189:1: char_val : CHAR_VAL -> ^( CHAR_VAL_NODE CHAR_VAL ) ;
	[GrammarRule("char_val")]
	private AstParserRuleReturnScope<CommonTree, IToken> char_val()
	{
		EnterRule_char_val();
		EnterRule("char_val", 20);
		TraceIn("char_val", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CHAR_VAL65 = default(IToken);

		CommonTree CHAR_VAL65_tree = default(CommonTree);
		RewriteRuleITokenStream stream_CHAR_VAL=new RewriteRuleITokenStream(adaptor,"token CHAR_VAL");
		try { DebugEnterRule(GrammarFileName, "char_val");
		DebugLocation(189, 2);
		try
		{
			// AbnfAst.g:190:2: ( CHAR_VAL -> ^( CHAR_VAL_NODE CHAR_VAL ) )
			DebugEnterAlt(1);
			// AbnfAst.g:191:3: CHAR_VAL
			{
			DebugLocation(191, 3);
			CHAR_VAL65=(IToken)Match(input,CHAR_VAL,Follow._CHAR_VAL_in_char_val957); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CHAR_VAL.Add(CHAR_VAL65);



			{
			// AST REWRITE
			// elements: CHAR_VAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 191:12: -> ^( CHAR_VAL_NODE CHAR_VAL )
			{
				DebugLocation(191, 15);
				// AbnfAst.g:191:15: ^( CHAR_VAL_NODE CHAR_VAL )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(191, 17);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CHAR_VAL_NODE, "CHAR_VAL_NODE"), root_1);

				DebugLocation(191, 31);
				adaptor.AddChild(root_1, stream_CHAR_VAL.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("char_val", 20);
			LeaveRule("char_val", 20);
			LeaveRule_char_val();
		}
		DebugLocation(194, 2);
		} finally { DebugExitRule(GrammarFileName, "char_val"); }
		return retval;

	}
	// $ANTLR end "char_val"

	partial void EnterRule_bin_val();
	partial void LeaveRule_bin_val();
	// $ANTLR start "bin_val"
	// AbnfAst.g:196:1: bin_val : ( BIN_VAL_PREFIX min= bin_val_number DASH max= bin_val_number -> ^( BIN_VAL_RANGE_NODE $min $max) | BIN_VAL_PREFIX bin_val_number ( '.' bin_val_number )+ -> ^( BIN_VAL_CONCAT_NODE ( bin_val_number )+ ) | BIN_VAL_PREFIX bin_val_number -> ^( BIN_VAL_NODE bin_val_number ) );
	[GrammarRule("bin_val")]
	private AstParserRuleReturnScope<CommonTree, IToken> bin_val()
	{
		EnterRule_bin_val();
		EnterRule("bin_val", 21);
		TraceIn("bin_val", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken BIN_VAL_PREFIX66 = default(IToken);
		IToken DASH67 = default(IToken);
		IToken BIN_VAL_PREFIX68 = default(IToken);
		IToken char_literal70 = default(IToken);
		IToken BIN_VAL_PREFIX72 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> min = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> max = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bin_val_number69 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bin_val_number71 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bin_val_number73 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree BIN_VAL_PREFIX66_tree = default(CommonTree);
		CommonTree DASH67_tree = default(CommonTree);
		CommonTree BIN_VAL_PREFIX68_tree = default(CommonTree);
		CommonTree char_literal70_tree = default(CommonTree);
		CommonTree BIN_VAL_PREFIX72_tree = default(CommonTree);
		RewriteRuleITokenStream stream_BIN_VAL_PREFIX=new RewriteRuleITokenStream(adaptor,"token BIN_VAL_PREFIX");
		RewriteRuleITokenStream stream_DASH=new RewriteRuleITokenStream(adaptor,"token DASH");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_bin_val_number=new RewriteRuleSubtreeStream(adaptor,"rule bin_val_number");
		try { DebugEnterRule(GrammarFileName, "bin_val");
		DebugLocation(196, 2);
		try
		{
			// AbnfAst.g:197:2: ( BIN_VAL_PREFIX min= bin_val_number DASH max= bin_val_number -> ^( BIN_VAL_RANGE_NODE $min $max) | BIN_VAL_PREFIX bin_val_number ( '.' bin_val_number )+ -> ^( BIN_VAL_CONCAT_NODE ( bin_val_number )+ ) | BIN_VAL_PREFIX bin_val_number -> ^( BIN_VAL_NODE bin_val_number ) )
			int alt23=3;
			try { DebugEnterDecision(23, false);
			try
			{
				alt23 = dfa23.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// AbnfAst.g:198:3: BIN_VAL_PREFIX min= bin_val_number DASH max= bin_val_number
				{
				DebugLocation(198, 3);
				BIN_VAL_PREFIX66=(IToken)Match(input,BIN_VAL_PREFIX,Follow._BIN_VAL_PREFIX_in_bin_val997); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BIN_VAL_PREFIX.Add(BIN_VAL_PREFIX66);

				DebugLocation(198, 21);
				PushFollow(Follow._bin_val_number_in_bin_val1001);
				min=bin_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bin_val_number.Add(min.Tree);
				DebugLocation(198, 37);
				DASH67=(IToken)Match(input,DASH,Follow._DASH_in_bin_val1003); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DASH.Add(DASH67);

				DebugLocation(198, 45);
				PushFollow(Follow._bin_val_number_in_bin_val1007);
				max=bin_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bin_val_number.Add(max.Tree);


				{
				// AST REWRITE
				// elements: min, max
				// token labels: 
				// rule labels: min, max, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_min=new RewriteRuleSubtreeStream(adaptor,"rule min",min!=null?min.Tree:null);
				RewriteRuleSubtreeStream stream_max=new RewriteRuleSubtreeStream(adaptor,"rule max",max!=null?max.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 198:61: -> ^( BIN_VAL_RANGE_NODE $min $max)
				{
					DebugLocation(198, 64);
					// AbnfAst.g:198:64: ^( BIN_VAL_RANGE_NODE $min $max)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(198, 66);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BIN_VAL_RANGE_NODE, "BIN_VAL_RANGE_NODE"), root_1);

					DebugLocation(198, 86);
					adaptor.AddChild(root_1, stream_min.NextTree());
					DebugLocation(198, 91);
					adaptor.AddChild(root_1, stream_max.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AbnfAst.g:199:5: BIN_VAL_PREFIX bin_val_number ( '.' bin_val_number )+
				{
				DebugLocation(199, 5);
				BIN_VAL_PREFIX68=(IToken)Match(input,BIN_VAL_PREFIX,Follow._BIN_VAL_PREFIX_in_bin_val1025); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BIN_VAL_PREFIX.Add(BIN_VAL_PREFIX68);

				DebugLocation(199, 20);
				PushFollow(Follow._bin_val_number_in_bin_val1027);
				bin_val_number69=bin_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bin_val_number.Add(bin_val_number69.Tree);
				DebugLocation(199, 35);
				// AbnfAst.g:199:35: ( '.' bin_val_number )+
				int cnt22=0;
				try { DebugEnterSubRule(22);
				while (true)
				{
					int alt22=2;
					try { DebugEnterDecision(22, false);
					int LA22_1 = input.LA(1);

					if ((LA22_1==55))
					{
						alt22 = 1;
					}


					} finally { DebugExitDecision(22); }
					switch (alt22)
					{
					case 1:
						DebugEnterAlt(1);
						// AbnfAst.g:199:36: '.' bin_val_number
						{
						DebugLocation(199, 36);
						char_literal70=(IToken)Match(input,55,Follow._55_in_bin_val1030); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_55.Add(char_literal70);

						DebugLocation(199, 40);
						PushFollow(Follow._bin_val_number_in_bin_val1032);
						bin_val_number71=bin_val_number();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_bin_val_number.Add(bin_val_number71.Tree);

						}
						break;

					default:
						if (cnt22 >= 1)
							goto loop22;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee22 = new EarlyExitException( 22, input );
						DebugRecognitionException(eee22);
						throw eee22;
					}
					cnt22++;
				}
				loop22:
					;

				} finally { DebugExitSubRule(22); }



				{
				// AST REWRITE
				// elements: bin_val_number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 199:61: -> ^( BIN_VAL_CONCAT_NODE ( bin_val_number )+ )
				{
					DebugLocation(199, 64);
					// AbnfAst.g:199:64: ^( BIN_VAL_CONCAT_NODE ( bin_val_number )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(199, 66);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BIN_VAL_CONCAT_NODE, "BIN_VAL_CONCAT_NODE"), root_1);

					DebugLocation(199, 86);
					if (!(stream_bin_val_number.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_bin_val_number.HasNext )
					{
						DebugLocation(199, 86);
						adaptor.AddChild(root_1, stream_bin_val_number.NextTree());

					}
					stream_bin_val_number.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AbnfAst.g:200:5: BIN_VAL_PREFIX bin_val_number
				{
				DebugLocation(200, 5);
				BIN_VAL_PREFIX72=(IToken)Match(input,BIN_VAL_PREFIX,Follow._BIN_VAL_PREFIX_in_bin_val1053); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BIN_VAL_PREFIX.Add(BIN_VAL_PREFIX72);

				DebugLocation(200, 20);
				PushFollow(Follow._bin_val_number_in_bin_val1055);
				bin_val_number73=bin_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bin_val_number.Add(bin_val_number73.Tree);


				{
				// AST REWRITE
				// elements: bin_val_number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 200:61: -> ^( BIN_VAL_NODE bin_val_number )
				{
					DebugLocation(200, 64);
					// AbnfAst.g:200:64: ^( BIN_VAL_NODE bin_val_number )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(200, 66);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BIN_VAL_NODE, "BIN_VAL_NODE"), root_1);

					DebugLocation(200, 79);
					adaptor.AddChild(root_1, stream_bin_val_number.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bin_val", 21);
			LeaveRule("bin_val", 21);
			LeaveRule_bin_val();
		}
		DebugLocation(203, 2);
		} finally { DebugExitRule(GrammarFileName, "bin_val"); }
		return retval;

	}
	// $ANTLR end "bin_val"

	partial void EnterRule_bin_val_number();
	partial void LeaveRule_bin_val_number();
	// $ANTLR start "bin_val_number"
	// AbnfAst.g:205:1: bin_val_number : bin_number -> ^( BIN_VAL_NUMBER_NODE bin_number ) ;
	[GrammarRule("bin_val_number")]
	private AstParserRuleReturnScope<CommonTree, IToken> bin_val_number()
	{
		EnterRule_bin_val_number();
		EnterRule("bin_val_number", 22);
		TraceIn("bin_val_number", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> bin_number74 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_bin_number=new RewriteRuleSubtreeStream(adaptor,"rule bin_number");
		try { DebugEnterRule(GrammarFileName, "bin_val_number");
		DebugLocation(205, 2);
		try
		{
			// AbnfAst.g:206:2: ( bin_number -> ^( BIN_VAL_NUMBER_NODE bin_number ) )
			DebugEnterAlt(1);
			// AbnfAst.g:207:3: bin_number
			{
			DebugLocation(207, 3);
			PushFollow(Follow._bin_number_in_bin_val_number1121);
			bin_number74=bin_number();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bin_number.Add(bin_number74.Tree);


			{
			// AST REWRITE
			// elements: bin_number
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 207:14: -> ^( BIN_VAL_NUMBER_NODE bin_number )
			{
				DebugLocation(207, 17);
				// AbnfAst.g:207:17: ^( BIN_VAL_NUMBER_NODE bin_number )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(207, 19);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BIN_VAL_NUMBER_NODE, "BIN_VAL_NUMBER_NODE"), root_1);

				DebugLocation(207, 39);
				adaptor.AddChild(root_1, stream_bin_number.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bin_val_number", 22);
			LeaveRule("bin_val_number", 22);
			LeaveRule_bin_val_number();
		}
		DebugLocation(208, 2);
		} finally { DebugExitRule(GrammarFileName, "bin_val_number"); }
		return retval;

	}
	// $ANTLR end "bin_val_number"

	partial void EnterRule_bin_number();
	partial void LeaveRule_bin_number();
	// $ANTLR start "bin_number"
	// AbnfAst.g:210:1: bin_number : ( ZERO | ONE )+ ;
	[GrammarRule("bin_number")]
	private AstParserRuleReturnScope<CommonTree, IToken> bin_number()
	{
		EnterRule_bin_number();
		EnterRule("bin_number", 23);
		TraceIn("bin_number", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set75 = default(IToken);

		CommonTree set75_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bin_number");
		DebugLocation(210, 2);
		try
		{
			// AbnfAst.g:211:2: ( ( ZERO | ONE )+ )
			DebugEnterAlt(1);
			// AbnfAst.g:212:3: ( ZERO | ONE )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(212, 3);
			// AbnfAst.g:212:3: ( ZERO | ONE )+
			int cnt24=0;
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==ONE||LA24_1==ZERO))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:
					{
					DebugLocation(212, 3);

					set75=(IToken)input.LT(1);
					if (input.LA(1)==ONE||input.LA(1)==ZERO)
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set75));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					if (cnt24 >= 1)
						goto loop24;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee24 = new EarlyExitException( 24, input );
					DebugRecognitionException(eee24);
					throw eee24;
				}
				cnt24++;
			}
			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bin_number", 23);
			LeaveRule("bin_number", 23);
			LeaveRule_bin_number();
		}
		DebugLocation(214, 2);
		} finally { DebugExitRule(GrammarFileName, "bin_number"); }
		return retval;

	}
	// $ANTLR end "bin_number"

	partial void EnterRule_dec_val();
	partial void LeaveRule_dec_val();
	// $ANTLR start "dec_val"
	// AbnfAst.g:216:1: dec_val : ( DEC_VAL_PREFIX min= dec_val_number DASH max= dec_val_number -> ^( DEC_VAL_RANGE_NODE $min $max) | DEC_VAL_PREFIX dec_val_number ( '.' dec_val_number )+ -> ^( DEC_VAL_CONCAT_NODE ( dec_val_number )+ ) | DEC_VAL_PREFIX dec_val_number -> ^( DEC_VAL_NODE dec_val_number ) );
	[GrammarRule("dec_val")]
	private AstParserRuleReturnScope<CommonTree, IToken> dec_val()
	{
		EnterRule_dec_val();
		EnterRule("dec_val", 24);
		TraceIn("dec_val", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DEC_VAL_PREFIX76 = default(IToken);
		IToken DASH77 = default(IToken);
		IToken DEC_VAL_PREFIX78 = default(IToken);
		IToken char_literal80 = default(IToken);
		IToken DEC_VAL_PREFIX82 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> min = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> max = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dec_val_number79 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dec_val_number81 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dec_val_number83 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DEC_VAL_PREFIX76_tree = default(CommonTree);
		CommonTree DASH77_tree = default(CommonTree);
		CommonTree DEC_VAL_PREFIX78_tree = default(CommonTree);
		CommonTree char_literal80_tree = default(CommonTree);
		CommonTree DEC_VAL_PREFIX82_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DEC_VAL_PREFIX=new RewriteRuleITokenStream(adaptor,"token DEC_VAL_PREFIX");
		RewriteRuleITokenStream stream_DASH=new RewriteRuleITokenStream(adaptor,"token DASH");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_dec_val_number=new RewriteRuleSubtreeStream(adaptor,"rule dec_val_number");
		try { DebugEnterRule(GrammarFileName, "dec_val");
		DebugLocation(216, 2);
		try
		{
			// AbnfAst.g:217:2: ( DEC_VAL_PREFIX min= dec_val_number DASH max= dec_val_number -> ^( DEC_VAL_RANGE_NODE $min $max) | DEC_VAL_PREFIX dec_val_number ( '.' dec_val_number )+ -> ^( DEC_VAL_CONCAT_NODE ( dec_val_number )+ ) | DEC_VAL_PREFIX dec_val_number -> ^( DEC_VAL_NODE dec_val_number ) )
			int alt26=3;
			try { DebugEnterDecision(26, false);
			try
			{
				alt26 = dfa26.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// AbnfAst.g:218:3: DEC_VAL_PREFIX min= dec_val_number DASH max= dec_val_number
				{
				DebugLocation(218, 3);
				DEC_VAL_PREFIX76=(IToken)Match(input,DEC_VAL_PREFIX,Follow._DEC_VAL_PREFIX_in_dec_val1169); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DEC_VAL_PREFIX.Add(DEC_VAL_PREFIX76);

				DebugLocation(218, 21);
				PushFollow(Follow._dec_val_number_in_dec_val1173);
				min=dec_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_dec_val_number.Add(min.Tree);
				DebugLocation(218, 37);
				DASH77=(IToken)Match(input,DASH,Follow._DASH_in_dec_val1175); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DASH.Add(DASH77);

				DebugLocation(218, 45);
				PushFollow(Follow._dec_val_number_in_dec_val1179);
				max=dec_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_dec_val_number.Add(max.Tree);


				{
				// AST REWRITE
				// elements: min, max
				// token labels: 
				// rule labels: min, max, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_min=new RewriteRuleSubtreeStream(adaptor,"rule min",min!=null?min.Tree:null);
				RewriteRuleSubtreeStream stream_max=new RewriteRuleSubtreeStream(adaptor,"rule max",max!=null?max.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 218:61: -> ^( DEC_VAL_RANGE_NODE $min $max)
				{
					DebugLocation(218, 64);
					// AbnfAst.g:218:64: ^( DEC_VAL_RANGE_NODE $min $max)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(218, 66);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DEC_VAL_RANGE_NODE, "DEC_VAL_RANGE_NODE"), root_1);

					DebugLocation(218, 86);
					adaptor.AddChild(root_1, stream_min.NextTree());
					DebugLocation(218, 91);
					adaptor.AddChild(root_1, stream_max.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AbnfAst.g:219:5: DEC_VAL_PREFIX dec_val_number ( '.' dec_val_number )+
				{
				DebugLocation(219, 5);
				DEC_VAL_PREFIX78=(IToken)Match(input,DEC_VAL_PREFIX,Follow._DEC_VAL_PREFIX_in_dec_val1197); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DEC_VAL_PREFIX.Add(DEC_VAL_PREFIX78);

				DebugLocation(219, 20);
				PushFollow(Follow._dec_val_number_in_dec_val1199);
				dec_val_number79=dec_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_dec_val_number.Add(dec_val_number79.Tree);
				DebugLocation(219, 35);
				// AbnfAst.g:219:35: ( '.' dec_val_number )+
				int cnt25=0;
				try { DebugEnterSubRule(25);
				while (true)
				{
					int alt25=2;
					try { DebugEnterDecision(25, false);
					int LA25_1 = input.LA(1);

					if ((LA25_1==55))
					{
						alt25 = 1;
					}


					} finally { DebugExitDecision(25); }
					switch (alt25)
					{
					case 1:
						DebugEnterAlt(1);
						// AbnfAst.g:219:36: '.' dec_val_number
						{
						DebugLocation(219, 36);
						char_literal80=(IToken)Match(input,55,Follow._55_in_dec_val1202); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_55.Add(char_literal80);

						DebugLocation(219, 40);
						PushFollow(Follow._dec_val_number_in_dec_val1204);
						dec_val_number81=dec_val_number();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_dec_val_number.Add(dec_val_number81.Tree);

						}
						break;

					default:
						if (cnt25 >= 1)
							goto loop25;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee25 = new EarlyExitException( 25, input );
						DebugRecognitionException(eee25);
						throw eee25;
					}
					cnt25++;
				}
				loop25:
					;

				} finally { DebugExitSubRule(25); }



				{
				// AST REWRITE
				// elements: dec_val_number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 219:61: -> ^( DEC_VAL_CONCAT_NODE ( dec_val_number )+ )
				{
					DebugLocation(219, 64);
					// AbnfAst.g:219:64: ^( DEC_VAL_CONCAT_NODE ( dec_val_number )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(219, 66);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DEC_VAL_CONCAT_NODE, "DEC_VAL_CONCAT_NODE"), root_1);

					DebugLocation(219, 86);
					if (!(stream_dec_val_number.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_dec_val_number.HasNext )
					{
						DebugLocation(219, 86);
						adaptor.AddChild(root_1, stream_dec_val_number.NextTree());

					}
					stream_dec_val_number.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AbnfAst.g:220:5: DEC_VAL_PREFIX dec_val_number
				{
				DebugLocation(220, 5);
				DEC_VAL_PREFIX82=(IToken)Match(input,DEC_VAL_PREFIX,Follow._DEC_VAL_PREFIX_in_dec_val1225); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DEC_VAL_PREFIX.Add(DEC_VAL_PREFIX82);

				DebugLocation(220, 20);
				PushFollow(Follow._dec_val_number_in_dec_val1227);
				dec_val_number83=dec_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_dec_val_number.Add(dec_val_number83.Tree);


				{
				// AST REWRITE
				// elements: dec_val_number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 220:61: -> ^( DEC_VAL_NODE dec_val_number )
				{
					DebugLocation(220, 64);
					// AbnfAst.g:220:64: ^( DEC_VAL_NODE dec_val_number )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(220, 66);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DEC_VAL_NODE, "DEC_VAL_NODE"), root_1);

					DebugLocation(220, 79);
					adaptor.AddChild(root_1, stream_dec_val_number.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dec_val", 24);
			LeaveRule("dec_val", 24);
			LeaveRule_dec_val();
		}
		DebugLocation(221, 2);
		} finally { DebugExitRule(GrammarFileName, "dec_val"); }
		return retval;

	}
	// $ANTLR end "dec_val"

	partial void EnterRule_dec_val_number();
	partial void LeaveRule_dec_val_number();
	// $ANTLR start "dec_val_number"
	// AbnfAst.g:223:1: dec_val_number : dec_number -> ^( DEC_VAL_NUMBER_NODE dec_number ) ;
	[GrammarRule("dec_val_number")]
	private AstParserRuleReturnScope<CommonTree, IToken> dec_val_number()
	{
		EnterRule_dec_val_number();
		EnterRule("dec_val_number", 25);
		TraceIn("dec_val_number", 25);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> dec_number84 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_dec_number=new RewriteRuleSubtreeStream(adaptor,"rule dec_number");
		try { DebugEnterRule(GrammarFileName, "dec_val_number");
		DebugLocation(223, 2);
		try
		{
			// AbnfAst.g:224:2: ( dec_number -> ^( DEC_VAL_NUMBER_NODE dec_number ) )
			DebugEnterAlt(1);
			// AbnfAst.g:225:3: dec_number
			{
			DebugLocation(225, 3);
			PushFollow(Follow._dec_number_in_dec_val_number1275);
			dec_number84=dec_number();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_dec_number.Add(dec_number84.Tree);


			{
			// AST REWRITE
			// elements: dec_number
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 225:14: -> ^( DEC_VAL_NUMBER_NODE dec_number )
			{
				DebugLocation(225, 17);
				// AbnfAst.g:225:17: ^( DEC_VAL_NUMBER_NODE dec_number )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(225, 19);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DEC_VAL_NUMBER_NODE, "DEC_VAL_NUMBER_NODE"), root_1);

				DebugLocation(225, 39);
				adaptor.AddChild(root_1, stream_dec_number.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dec_val_number", 25);
			LeaveRule("dec_val_number", 25);
			LeaveRule_dec_val_number();
		}
		DebugLocation(226, 2);
		} finally { DebugExitRule(GrammarFileName, "dec_val_number"); }
		return retval;

	}
	// $ANTLR end "dec_val_number"

	partial void EnterRule_dec_number();
	partial void LeaveRule_dec_number();
	// $ANTLR start "dec_number"
	// AbnfAst.g:228:1: dec_number : ( ZERO | ONE | OTHER_DIGIT )+ ;
	[GrammarRule("dec_number")]
	private AstParserRuleReturnScope<CommonTree, IToken> dec_number()
	{
		EnterRule_dec_number();
		EnterRule("dec_number", 26);
		TraceIn("dec_number", 26);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set85 = default(IToken);

		CommonTree set85_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "dec_number");
		DebugLocation(228, 2);
		try
		{
			// AbnfAst.g:229:2: ( ( ZERO | ONE | OTHER_DIGIT )+ )
			DebugEnterAlt(1);
			// AbnfAst.g:230:3: ( ZERO | ONE | OTHER_DIGIT )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(230, 3);
			// AbnfAst.g:230:3: ( ZERO | ONE | OTHER_DIGIT )+
			int cnt27=0;
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1==ONE||LA27_1==OTHER_DIGIT||LA27_1==ZERO))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:
					{
					DebugLocation(230, 3);

					set85=(IToken)input.LT(1);
					if (input.LA(1)==ONE||input.LA(1)==OTHER_DIGIT||input.LA(1)==ZERO)
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set85));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					if (cnt27 >= 1)
						goto loop27;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee27 = new EarlyExitException( 27, input );
					DebugRecognitionException(eee27);
					throw eee27;
				}
				cnt27++;
			}
			loop27:
				;

			} finally { DebugExitSubRule(27); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dec_number", 26);
			LeaveRule("dec_number", 26);
			LeaveRule_dec_number();
		}
		DebugLocation(232, 2);
		} finally { DebugExitRule(GrammarFileName, "dec_number"); }
		return retval;

	}
	// $ANTLR end "dec_number"

	partial void EnterRule_hex_val();
	partial void LeaveRule_hex_val();
	// $ANTLR start "hex_val"
	// AbnfAst.g:234:1: hex_val : ( HEX_VAL_PREFIX min= hex_val_number DASH max= hex_val_number -> ^( HEX_VAL_RANGE_NODE $min $max) | HEX_VAL_PREFIX hex_val_number ( '.' hex_val_number )+ -> ^( HEX_VAL_CONCAT_NODE ( hex_val_number )+ ) | HEX_VAL_PREFIX hex_val_number -> ^( HEX_VAL_NODE hex_val_number ) );
	[GrammarRule("hex_val")]
	private AstParserRuleReturnScope<CommonTree, IToken> hex_val()
	{
		EnterRule_hex_val();
		EnterRule("hex_val", 27);
		TraceIn("hex_val", 27);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken HEX_VAL_PREFIX86 = default(IToken);
		IToken DASH87 = default(IToken);
		IToken HEX_VAL_PREFIX88 = default(IToken);
		IToken char_literal90 = default(IToken);
		IToken HEX_VAL_PREFIX92 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> min = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> max = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> hex_val_number89 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> hex_val_number91 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> hex_val_number93 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree HEX_VAL_PREFIX86_tree = default(CommonTree);
		CommonTree DASH87_tree = default(CommonTree);
		CommonTree HEX_VAL_PREFIX88_tree = default(CommonTree);
		CommonTree char_literal90_tree = default(CommonTree);
		CommonTree HEX_VAL_PREFIX92_tree = default(CommonTree);
		RewriteRuleITokenStream stream_HEX_VAL_PREFIX=new RewriteRuleITokenStream(adaptor,"token HEX_VAL_PREFIX");
		RewriteRuleITokenStream stream_DASH=new RewriteRuleITokenStream(adaptor,"token DASH");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_hex_val_number=new RewriteRuleSubtreeStream(adaptor,"rule hex_val_number");
		try { DebugEnterRule(GrammarFileName, "hex_val");
		DebugLocation(234, 2);
		try
		{
			// AbnfAst.g:235:2: ( HEX_VAL_PREFIX min= hex_val_number DASH max= hex_val_number -> ^( HEX_VAL_RANGE_NODE $min $max) | HEX_VAL_PREFIX hex_val_number ( '.' hex_val_number )+ -> ^( HEX_VAL_CONCAT_NODE ( hex_val_number )+ ) | HEX_VAL_PREFIX hex_val_number -> ^( HEX_VAL_NODE hex_val_number ) )
			int alt29=3;
			try { DebugEnterDecision(29, false);
			try
			{
				alt29 = dfa29.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// AbnfAst.g:236:3: HEX_VAL_PREFIX min= hex_val_number DASH max= hex_val_number
				{
				DebugLocation(236, 3);
				HEX_VAL_PREFIX86=(IToken)Match(input,HEX_VAL_PREFIX,Follow._HEX_VAL_PREFIX_in_hex_val1325); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_HEX_VAL_PREFIX.Add(HEX_VAL_PREFIX86);

				DebugLocation(236, 21);
				PushFollow(Follow._hex_val_number_in_hex_val1329);
				min=hex_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_hex_val_number.Add(min.Tree);
				DebugLocation(236, 37);
				DASH87=(IToken)Match(input,DASH,Follow._DASH_in_hex_val1331); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DASH.Add(DASH87);

				DebugLocation(236, 45);
				PushFollow(Follow._hex_val_number_in_hex_val1335);
				max=hex_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_hex_val_number.Add(max.Tree);


				{
				// AST REWRITE
				// elements: min, max
				// token labels: 
				// rule labels: min, max, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_min=new RewriteRuleSubtreeStream(adaptor,"rule min",min!=null?min.Tree:null);
				RewriteRuleSubtreeStream stream_max=new RewriteRuleSubtreeStream(adaptor,"rule max",max!=null?max.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 236:61: -> ^( HEX_VAL_RANGE_NODE $min $max)
				{
					DebugLocation(236, 64);
					// AbnfAst.g:236:64: ^( HEX_VAL_RANGE_NODE $min $max)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(236, 66);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(HEX_VAL_RANGE_NODE, "HEX_VAL_RANGE_NODE"), root_1);

					DebugLocation(236, 86);
					adaptor.AddChild(root_1, stream_min.NextTree());
					DebugLocation(236, 91);
					adaptor.AddChild(root_1, stream_max.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AbnfAst.g:237:5: HEX_VAL_PREFIX hex_val_number ( '.' hex_val_number )+
				{
				DebugLocation(237, 5);
				HEX_VAL_PREFIX88=(IToken)Match(input,HEX_VAL_PREFIX,Follow._HEX_VAL_PREFIX_in_hex_val1353); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_HEX_VAL_PREFIX.Add(HEX_VAL_PREFIX88);

				DebugLocation(237, 20);
				PushFollow(Follow._hex_val_number_in_hex_val1355);
				hex_val_number89=hex_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_hex_val_number.Add(hex_val_number89.Tree);
				DebugLocation(237, 35);
				// AbnfAst.g:237:35: ( '.' hex_val_number )+
				int cnt28=0;
				try { DebugEnterSubRule(28);
				while (true)
				{
					int alt28=2;
					try { DebugEnterDecision(28, false);
					int LA28_1 = input.LA(1);

					if ((LA28_1==55))
					{
						alt28 = 1;
					}


					} finally { DebugExitDecision(28); }
					switch (alt28)
					{
					case 1:
						DebugEnterAlt(1);
						// AbnfAst.g:237:36: '.' hex_val_number
						{
						DebugLocation(237, 36);
						char_literal90=(IToken)Match(input,55,Follow._55_in_hex_val1358); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_55.Add(char_literal90);

						DebugLocation(237, 40);
						PushFollow(Follow._hex_val_number_in_hex_val1360);
						hex_val_number91=hex_val_number();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_hex_val_number.Add(hex_val_number91.Tree);

						}
						break;

					default:
						if (cnt28 >= 1)
							goto loop28;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee28 = new EarlyExitException( 28, input );
						DebugRecognitionException(eee28);
						throw eee28;
					}
					cnt28++;
				}
				loop28:
					;

				} finally { DebugExitSubRule(28); }



				{
				// AST REWRITE
				// elements: hex_val_number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 237:61: -> ^( HEX_VAL_CONCAT_NODE ( hex_val_number )+ )
				{
					DebugLocation(237, 64);
					// AbnfAst.g:237:64: ^( HEX_VAL_CONCAT_NODE ( hex_val_number )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(237, 66);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(HEX_VAL_CONCAT_NODE, "HEX_VAL_CONCAT_NODE"), root_1);

					DebugLocation(237, 86);
					if (!(stream_hex_val_number.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_hex_val_number.HasNext )
					{
						DebugLocation(237, 86);
						adaptor.AddChild(root_1, stream_hex_val_number.NextTree());

					}
					stream_hex_val_number.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AbnfAst.g:238:5: HEX_VAL_PREFIX hex_val_number
				{
				DebugLocation(238, 5);
				HEX_VAL_PREFIX92=(IToken)Match(input,HEX_VAL_PREFIX,Follow._HEX_VAL_PREFIX_in_hex_val1381); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_HEX_VAL_PREFIX.Add(HEX_VAL_PREFIX92);

				DebugLocation(238, 20);
				PushFollow(Follow._hex_val_number_in_hex_val1383);
				hex_val_number93=hex_val_number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_hex_val_number.Add(hex_val_number93.Tree);


				{
				// AST REWRITE
				// elements: hex_val_number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 238:61: -> ^( HEX_VAL_NODE hex_val_number )
				{
					DebugLocation(238, 64);
					// AbnfAst.g:238:64: ^( HEX_VAL_NODE hex_val_number )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(238, 66);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(HEX_VAL_NODE, "HEX_VAL_NODE"), root_1);

					DebugLocation(238, 79);
					adaptor.AddChild(root_1, stream_hex_val_number.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("hex_val", 27);
			LeaveRule("hex_val", 27);
			LeaveRule_hex_val();
		}
		DebugLocation(239, 2);
		} finally { DebugExitRule(GrammarFileName, "hex_val"); }
		return retval;

	}
	// $ANTLR end "hex_val"

	partial void EnterRule_hex_val_number();
	partial void LeaveRule_hex_val_number();
	// $ANTLR start "hex_val_number"
	// AbnfAst.g:241:1: hex_val_number : hex_number -> ^( HEX_VAL_NUMBER_NODE hex_number ) ;
	[GrammarRule("hex_val_number")]
	private AstParserRuleReturnScope<CommonTree, IToken> hex_val_number()
	{
		EnterRule_hex_val_number();
		EnterRule("hex_val_number", 28);
		TraceIn("hex_val_number", 28);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> hex_number94 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_hex_number=new RewriteRuleSubtreeStream(adaptor,"rule hex_number");
		try { DebugEnterRule(GrammarFileName, "hex_val_number");
		DebugLocation(241, 2);
		try
		{
			// AbnfAst.g:242:2: ( hex_number -> ^( HEX_VAL_NUMBER_NODE hex_number ) )
			DebugEnterAlt(1);
			// AbnfAst.g:243:3: hex_number
			{
			DebugLocation(243, 3);
			PushFollow(Follow._hex_number_in_hex_val_number1431);
			hex_number94=hex_number();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_hex_number.Add(hex_number94.Tree);


			{
			// AST REWRITE
			// elements: hex_number
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 243:14: -> ^( HEX_VAL_NUMBER_NODE hex_number )
			{
				DebugLocation(243, 17);
				// AbnfAst.g:243:17: ^( HEX_VAL_NUMBER_NODE hex_number )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(243, 19);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(HEX_VAL_NUMBER_NODE, "HEX_VAL_NUMBER_NODE"), root_1);

				DebugLocation(243, 39);
				adaptor.AddChild(root_1, stream_hex_number.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("hex_val_number", 28);
			LeaveRule("hex_val_number", 28);
			LeaveRule_hex_val_number();
		}
		DebugLocation(244, 2);
		} finally { DebugExitRule(GrammarFileName, "hex_val_number"); }
		return retval;

	}
	// $ANTLR end "hex_val_number"

	partial void EnterRule_hex_number();
	partial void LeaveRule_hex_number();
	// $ANTLR start "hex_number"
	// AbnfAst.g:246:1: hex_number : ( ZERO | ONE | OTHER_DIGIT | HEX_ALPHA )+ ;
	[GrammarRule("hex_number")]
	private AstParserRuleReturnScope<CommonTree, IToken> hex_number()
	{
		EnterRule_hex_number();
		EnterRule("hex_number", 29);
		TraceIn("hex_number", 29);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set95 = default(IToken);

		CommonTree set95_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "hex_number");
		DebugLocation(246, 2);
		try
		{
			// AbnfAst.g:247:2: ( ( ZERO | ONE | OTHER_DIGIT | HEX_ALPHA )+ )
			DebugEnterAlt(1);
			// AbnfAst.g:248:3: ( ZERO | ONE | OTHER_DIGIT | HEX_ALPHA )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(248, 3);
			// AbnfAst.g:248:3: ( ZERO | ONE | OTHER_DIGIT | HEX_ALPHA )+
			int cnt30=0;
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if ((LA30_1==HEX_ALPHA||LA30_1==ONE||LA30_1==OTHER_DIGIT||LA30_1==ZERO))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch (alt30)
				{
				case 1:
					DebugEnterAlt(1);
					// AbnfAst.g:
					{
					DebugLocation(248, 3);

					set95=(IToken)input.LT(1);
					if (input.LA(1)==HEX_ALPHA||input.LA(1)==ONE||input.LA(1)==OTHER_DIGIT||input.LA(1)==ZERO)
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set95));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					if (cnt30 >= 1)
						goto loop30;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee30 = new EarlyExitException( 30, input );
					DebugRecognitionException(eee30);
					throw eee30;
				}
				cnt30++;
			}
			loop30:
				;

			} finally { DebugExitSubRule(30); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("hex_number", 29);
			LeaveRule("hex_number", 29);
			LeaveRule_hex_number();
		}
		DebugLocation(250, 2);
		} finally { DebugExitRule(GrammarFileName, "hex_number"); }
		return retval;

	}
	// $ANTLR end "hex_number"

	partial void EnterRule_prose_val();
	partial void LeaveRule_prose_val();
	// $ANTLR start "prose_val"
	// AbnfAst.g:252:1: prose_val : PROSE_VAL -> ^( PROSE_VAL_NODE PROSE_VAL ) ;
	[GrammarRule("prose_val")]
	private AstParserRuleReturnScope<CommonTree, IToken> prose_val()
	{
		EnterRule_prose_val();
		EnterRule("prose_val", 30);
		TraceIn("prose_val", 30);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken PROSE_VAL96 = default(IToken);

		CommonTree PROSE_VAL96_tree = default(CommonTree);
		RewriteRuleITokenStream stream_PROSE_VAL=new RewriteRuleITokenStream(adaptor,"token PROSE_VAL");
		try { DebugEnterRule(GrammarFileName, "prose_val");
		DebugLocation(252, 2);
		try
		{
			// AbnfAst.g:253:2: ( PROSE_VAL -> ^( PROSE_VAL_NODE PROSE_VAL ) )
			DebugEnterAlt(1);
			// AbnfAst.g:254:3: PROSE_VAL
			{
			DebugLocation(254, 3);
			PROSE_VAL96=(IToken)Match(input,PROSE_VAL,Follow._PROSE_VAL_in_prose_val1485); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PROSE_VAL.Add(PROSE_VAL96);



			{
			// AST REWRITE
			// elements: PROSE_VAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 254:13: -> ^( PROSE_VAL_NODE PROSE_VAL )
			{
				DebugLocation(254, 16);
				// AbnfAst.g:254:16: ^( PROSE_VAL_NODE PROSE_VAL )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(254, 18);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROSE_VAL_NODE, "PROSE_VAL_NODE"), root_1);

				DebugLocation(254, 33);
				adaptor.AddChild(root_1, stream_PROSE_VAL.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prose_val", 30);
			LeaveRule("prose_val", 30);
			LeaveRule_prose_val();
		}
		DebugLocation(259, 2);
		} finally { DebugExitRule(GrammarFileName, "prose_val"); }
		return retval;

	}
	// $ANTLR end "prose_val"

	partial void EnterRule_synpred1_AbnfAst_fragment();
	partial void LeaveRule_synpred1_AbnfAst_fragment();

	// $ANTLR start synpred1_AbnfAst
	public void synpred1_AbnfAst_fragment()
	{
		EnterRule_synpred1_AbnfAst_fragment();
		EnterRule("synpred1_AbnfAst_fragment", 31);
		TraceIn("synpred1_AbnfAst_fragment", 31);
		try
		{
			// AbnfAst.g:84:20: ( c_nl )
			DebugEnterAlt(1);
			// AbnfAst.g:84:21: c_nl
			{
			DebugLocation(84, 21);
			PushFollow(Follow._c_nl_in_synpred1_AbnfAst191);
			c_nl();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_AbnfAst_fragment", 31);
			LeaveRule("synpred1_AbnfAst_fragment", 31);
			LeaveRule_synpred1_AbnfAst_fragment();
		}
	}
	// $ANTLR end synpred1_AbnfAst

	partial void EnterRule_synpred2_AbnfAst_fragment();
	partial void LeaveRule_synpred2_AbnfAst_fragment();

	// $ANTLR start synpred2_AbnfAst
	public void synpred2_AbnfAst_fragment()
	{
		EnterRule_synpred2_AbnfAst_fragment();
		EnterRule("synpred2_AbnfAst_fragment", 32);
		TraceIn("synpred2_AbnfAst_fragment", 32);
		try
		{
			// AbnfAst.g:114:16: ( c_wsp )
			DebugEnterAlt(1);
			// AbnfAst.g:114:17: c_wsp
			{
			DebugLocation(114, 17);
			PushFollow(Follow._c_wsp_in_synpred2_AbnfAst369);
			c_wsp();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_AbnfAst_fragment", 32);
			LeaveRule("synpred2_AbnfAst_fragment", 32);
			LeaveRule_synpred2_AbnfAst_fragment();
		}
	}
	// $ANTLR end synpred2_AbnfAst
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA6 dfa6;
	private DFA11 dfa11;
	private DFA13 dfa13;
	private DFA14 dfa14;
	private DFA23 dfa23;
	private DFA26 dfa26;
	private DFA29 dfa29;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa6 = new DFA6( this, SpecialStateTransition6 );
		dfa11 = new DFA11( this );
		dfa13 = new DFA13( this );
		dfa14 = new DFA14( this );
		dfa23 = new DFA23( this );
		dfa26 = new DFA26( this );
		dfa29 = new DFA29( this );
	}

	private class DFA6 : DFA
	{
		private const string DFA6_eotS =
			"\xB\xFFFF";
		private const string DFA6_eofS =
			"\x1\xFFFF\x2\x4\x8\xFFFF";
		private const string DFA6_minS =
			"\x3\xD\x2\xFFFF\x1\xD\x2\x0\x1\xD\x2\x0";
		private const string DFA6_maxS =
			"\x3\x32\x2\xFFFF\x1\x32\x2\x0\x1\x32\x2\x0";
		private const string DFA6_acceptS =
			"\x3\xFFFF\x1\x1\x1\x2\x6\xFFFF";
		private const string DFA6_specialS =
			"\x1\x0\x5\xFFFF\x1\x1\x1\x2\x1\xFFFF\x1\x3\x1\x4}>";
		private static readonly string[] DFA6_transitionS =
			{
				"\x1\x1\x2\xFFFF\x1\x2\x21\xFFFF\x1\x3",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x5",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x5",
				"",
				"",
				"\x1\x6\x2\xFFFF\x1\x7\x21\xFFFF\x1\x8",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\x9\x2\xFFFF\x1\xA\x21\xFFFF\x1\x8",
				"\x1\xFFFF",
				"\x1\xFFFF"
			};

		private static readonly short[] DFA6_eot = DFA.UnpackEncodedString(DFA6_eotS);
		private static readonly short[] DFA6_eof = DFA.UnpackEncodedString(DFA6_eofS);
		private static readonly char[] DFA6_min = DFA.UnpackEncodedStringToUnsignedChars(DFA6_minS);
		private static readonly char[] DFA6_max = DFA.UnpackEncodedStringToUnsignedChars(DFA6_maxS);
		private static readonly short[] DFA6_accept = DFA.UnpackEncodedString(DFA6_acceptS);
		private static readonly short[] DFA6_special = DFA.UnpackEncodedString(DFA6_specialS);
		private static readonly short[][] DFA6_transition;

		static DFA6()
		{
			int numStates = DFA6_transitionS.Length;
			DFA6_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA6_transition[i] = DFA.UnpackEncodedString(DFA6_transitionS[i]);
			}
		}

		public DFA6( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 6;
			this.eot = DFA6_eot;
			this.eof = DFA6_eof;
			this.min = DFA6_min;
			this.max = DFA6_max;
			this.accept = DFA6_accept;
			this.special = DFA6_special;
			this.transition = DFA6_transition;
		}

		public override string Description { get { return "()* loopback of 114:15: ( ( c_wsp )=> c_wsp )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition6(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		s = -1;
		int LA6_1 = input.LA(1);
		int index6_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA6_1==COMMENT)) {s = 1;}

				else if ((LA6_1==CRLF)) {s = 2;}

				else if ((LA6_1==WSP) && (EvaluatePredicate(synpred2_AbnfAst_fragment))) {s = 3;}

				input.Seek(index6_1);
				break;
			}
		case 1:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred2_AbnfAst_fragment))) {s = 3;}

				else if ((true)) {s = 4;}

				input.Seek(index6_1);
				break;
			}
		case 2:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred2_AbnfAst_fragment))) {s = 3;}

				else if ((true)) {s = 4;}

				input.Seek(index6_1);
				break;
			}
		case 3:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred2_AbnfAst_fragment))) {s = 3;}

				else if ((true)) {s = 4;}

				input.Seek(index6_1);
				break;
			}
		case 4:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred2_AbnfAst_fragment))) {s = 3;}

				else if ((true)) {s = 4;}

				input.Seek(index6_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 6, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA11 : DFA
	{
		private const string DFA11_eotS =
			"\x12\xFFFF";
		private const string DFA11_eofS =
			"\x2\xFFFF\x2\x4\x2\xFFFF\x2\x4\x2\xFFFF\x2\x4\x1\xFFFF\x2\x4\x3\xFFFF";
		private const string DFA11_minS =
			"\x4\xD\x2\xFFFF\xC\xD";
		private const string DFA11_maxS =
			"\x2\x3C\x2\x32\x2\xFFFF\x2\x32\x2\x3C\x2\x32\x1\x3C\x2\x32\x3\x3C";
		private const string DFA11_acceptS =
			"\x4\xFFFF\x1\x2\x1\x1\xC\xFFFF";
		private const string DFA11_specialS =
			"\x12\xFFFF}>";
		private static readonly string[] DFA11_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x3\x21\xFFFF\x1\x1\x3\xFFFF\x1\x4\x1\xFFFF\x1\x5"+
				"\x3\xFFFF\x1\x4",
				"\x1\x6\x2\xFFFF\x1\x7\x21\xFFFF\x1\x1\x3\xFFFF\x1\x4\x1\xFFFF\x1\x5"+
				"\x3\xFFFF\x1\x4",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x8",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x8",
				"",
				"",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x9",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x9",
				"\x1\xA\x2\xFFFF\x1\xB\x21\xFFFF\x1\xC\x3\xFFFF\x1\x4\x1\xFFFF\x1\x5"+
				"\x3\xFFFF\x1\x4",
				"\x1\xD\x2\xFFFF\x1\xE\x21\xFFFF\x1\xF\x3\xFFFF\x1\x4\x1\xFFFF\x1\x5"+
				"\x3\xFFFF\x1\x4",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x10",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x10",
				"\x1\xA\x2\xFFFF\x1\xB\x21\xFFFF\x1\xC\x3\xFFFF\x1\x4\x1\xFFFF\x1\x5"+
				"\x3\xFFFF\x1\x4",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x11",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x11",
				"\x1\xD\x2\xFFFF\x1\xE\x21\xFFFF\x1\xF\x3\xFFFF\x1\x4\x1\xFFFF\x1\x5"+
				"\x3\xFFFF\x1\x4",
				"\x1\xD\x2\xFFFF\x1\xE\x21\xFFFF\x1\xF\x3\xFFFF\x1\x4\x1\xFFFF\x1\x5"+
				"\x3\xFFFF\x1\x4",
				"\x1\xD\x2\xFFFF\x1\xE\x21\xFFFF\x1\xF\x3\xFFFF\x1\x4\x1\xFFFF\x1\x5"+
				"\x3\xFFFF\x1\x4"
			};

		private static readonly short[] DFA11_eot = DFA.UnpackEncodedString(DFA11_eotS);
		private static readonly short[] DFA11_eof = DFA.UnpackEncodedString(DFA11_eofS);
		private static readonly char[] DFA11_min = DFA.UnpackEncodedStringToUnsignedChars(DFA11_minS);
		private static readonly char[] DFA11_max = DFA.UnpackEncodedStringToUnsignedChars(DFA11_maxS);
		private static readonly short[] DFA11_accept = DFA.UnpackEncodedString(DFA11_acceptS);
		private static readonly short[] DFA11_special = DFA.UnpackEncodedString(DFA11_specialS);
		private static readonly short[][] DFA11_transition;

		static DFA11()
		{
			int numStates = DFA11_transitionS.Length;
			DFA11_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA11_transition[i] = DFA.UnpackEncodedString(DFA11_transitionS[i]);
			}
		}

		public DFA11( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 11;
			this.eot = DFA11_eot;
			this.eof = DFA11_eof;
			this.min = DFA11_min;
			this.max = DFA11_max;
			this.accept = DFA11_accept;
			this.special = DFA11_special;
			this.transition = DFA11_transition;
		}

		public override string Description { get { return "()* loopback of 135:17: ( ( c_wsp )* '/' ( c_wsp )* concatenation )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA13 : DFA
	{
		private const string DFA13_eotS =
			"\x12\xFFFF";
		private const string DFA13_eofS =
			"\x2\xFFFF\x2\x4\x1\xFFFF\x2\x4\x4\xFFFF\x2\x4\x1\xFFFF\x2\x4\x2\xFFFF";
		private const string DFA13_minS =
			"\x1\xD\x1\x5\x2\xD\x1\xFFFF\x2\xD\x1\xFFFF\x3\x5\x2\xD\x1\x5\x2\xD\x2"+
			"\x5";
		private const string DFA13_maxS =
			"\x2\x3C\x2\x32\x1\xFFFF\x2\x32\x1\xFFFF\x3\x3C\x2\x32\x1\x3C\x2\x32\x2"+
			"\x3C";
		private const string DFA13_acceptS =
			"\x4\xFFFF\x1\x2\x2\xFFFF\x1\x1\xA\xFFFF";
		private const string DFA13_specialS =
			"\x12\xFFFF}>";
		private static readonly string[] DFA13_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x3\x21\xFFFF\x1\x1\x3\xFFFF\x1\x4\x1\xFFFF\x1\x4"+
				"\x3\xFFFF\x1\x4",
				"\x1\x7\x3\xFFFF\x1\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\x5\x2\xFFFF\x1\x6\x4"+
				"\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x3"+
				"\x7\x8\xFFFF\x1\x1\x1\x7\x1\xFFFF\x1\x7\x1\x4\x1\xFFFF\x1\x4\x2\xFFFF"+
				"\x1\x7\x1\x4",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x8",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x8",
				"",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x9",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x9",
				"",
				"\x1\x7\x3\xFFFF\x1\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\xB\x2\xFFFF\x1\xC\x4"+
				"\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x3"+
				"\x7\x8\xFFFF\x1\xA\x1\x7\x1\xFFFF\x1\x7\x1\x4\x1\xFFFF\x1\x4\x2\xFFFF"+
				"\x1\x7\x1\x4",
				"\x1\x7\x3\xFFFF\x1\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\xE\x2\xFFFF\x1\xF\x4"+
				"\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x3"+
				"\x7\x8\xFFFF\x1\xD\x1\x7\x1\xFFFF\x1\x7\x1\x4\x1\xFFFF\x1\x4\x2\xFFFF"+
				"\x1\x7\x1\x4",
				"\x1\x7\x3\xFFFF\x1\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\xB\x2\xFFFF\x1\xC\x4"+
				"\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x3"+
				"\x7\x8\xFFFF\x1\xA\x1\x7\x1\xFFFF\x1\x7\x1\x4\x1\xFFFF\x1\x4\x2\xFFFF"+
				"\x1\x7\x1\x4",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x10",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x10",
				"\x1\x7\x3\xFFFF\x1\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\xE\x2\xFFFF\x1\xF\x4"+
				"\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x3"+
				"\x7\x8\xFFFF\x1\xD\x1\x7\x1\xFFFF\x1\x7\x1\x4\x1\xFFFF\x1\x4\x2\xFFFF"+
				"\x1\x7\x1\x4",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x11",
				"\x1\x4\x2\xFFFF\x1\x4\x9\xFFFF\x1\x4\xC\xFFFF\x1\x4\xA\xFFFF\x1\x11",
				"\x1\x7\x3\xFFFF\x1\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\xE\x2\xFFFF\x1\xF\x4"+
				"\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x3"+
				"\x7\x8\xFFFF\x1\xD\x1\x7\x1\xFFFF\x1\x7\x1\x4\x1\xFFFF\x1\x4\x2\xFFFF"+
				"\x1\x7\x1\x4",
				"\x1\x7\x3\xFFFF\x1\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\xE\x2\xFFFF\x1\xF\x4"+
				"\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3\xFFFF\x3"+
				"\x7\x8\xFFFF\x1\xD\x1\x7\x1\xFFFF\x1\x7\x1\x4\x1\xFFFF\x1\x4\x2\xFFFF"+
				"\x1\x7\x1\x4"
			};

		private static readonly short[] DFA13_eot = DFA.UnpackEncodedString(DFA13_eotS);
		private static readonly short[] DFA13_eof = DFA.UnpackEncodedString(DFA13_eofS);
		private static readonly char[] DFA13_min = DFA.UnpackEncodedStringToUnsignedChars(DFA13_minS);
		private static readonly char[] DFA13_max = DFA.UnpackEncodedStringToUnsignedChars(DFA13_maxS);
		private static readonly short[] DFA13_accept = DFA.UnpackEncodedString(DFA13_acceptS);
		private static readonly short[] DFA13_special = DFA.UnpackEncodedString(DFA13_specialS);
		private static readonly short[][] DFA13_transition;

		static DFA13()
		{
			int numStates = DFA13_transitionS.Length;
			DFA13_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA13_transition[i] = DFA.UnpackEncodedString(DFA13_transitionS[i]);
			}
		}

		public DFA13( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 13;
			this.eot = DFA13_eot;
			this.eof = DFA13_eof;
			this.min = DFA13_min;
			this.max = DFA13_max;
			this.accept = DFA13_accept;
			this.special = DFA13_special;
			this.transition = DFA13_transition;
		}

		public override string Description { get { return "()* loopback of 140:14: ( ( c_wsp )+ repetition )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA14 : DFA
	{
		private const string DFA14_eotS =
			"\xA\xFFFF";
		private const string DFA14_eofS =
			"\xA\xFFFF";
		private const string DFA14_minS =
			"\x1\x5\x1\x9\x1\x5\x3\xFFFF\x1\x9\x3\xFFFF";
		private const string DFA14_maxS =
			"\x3\x3B\x3\xFFFF\x1\x3B\x3\xFFFF";
		private const string DFA14_acceptS =
			"\x3\xFFFF\x1\x6\x1\x1\x1\x4\x1\xFFFF\x1\x5\x1\x2\x1\x3";
		private const string DFA14_specialS =
			"\xA\xFFFF}>";
		private static readonly string[] DFA14_transitionS =
			{
				"\x1\x1\x3\xFFFF\x1\x3\x1\xFFFF\x1\x3\x9\xFFFF\x1\x3\x4\xFFFF\x1\x3\x3"+
				"\xFFFF\x1\x3\x4\xFFFF\x1\x2\x3\xFFFF\x1\x3\x1\x2\x1\x3\x9\xFFFF\x1\x2"+
				"\x1\xFFFF\x1\x3\x5\xFFFF\x1\x3",
				"\x1\x5\x1\xFFFF\x1\x5\x9\xFFFF\x1\x5\x4\xFFFF\x1\x5\x3\xFFFF\x1\x5\x4"+
				"\xFFFF\x1\x4\x3\xFFFF\x1\x5\x1\x4\x1\x5\x9\xFFFF\x1\x4\x1\xFFFF\x1\x5"+
				"\x5\xFFFF\x1\x5",
				"\x1\x6\x3\xFFFF\x1\x7\x1\xFFFF\x1\x7\x9\xFFFF\x1\x7\x4\xFFFF\x1\x7\x3"+
				"\xFFFF\x1\x7\x4\xFFFF\x1\x2\x3\xFFFF\x1\x7\x1\x2\x1\x7\x9\xFFFF\x1\x2"+
				"\x1\xFFFF\x1\x7\x5\xFFFF\x1\x7",
				"",
				"",
				"",
				"\x1\x9\x1\xFFFF\x1\x9\x9\xFFFF\x1\x9\x4\xFFFF\x1\x9\x3\xFFFF\x1\x9\x4"+
				"\xFFFF\x1\x8\x3\xFFFF\x1\x9\x1\x8\x1\x9\x9\xFFFF\x1\x8\x1\xFFFF\x1\x9"+
				"\x5\xFFFF\x1\x9",
				"",
				"",
				""
			};

		private static readonly short[] DFA14_eot = DFA.UnpackEncodedString(DFA14_eotS);
		private static readonly short[] DFA14_eof = DFA.UnpackEncodedString(DFA14_eofS);
		private static readonly char[] DFA14_min = DFA.UnpackEncodedStringToUnsignedChars(DFA14_minS);
		private static readonly char[] DFA14_max = DFA.UnpackEncodedStringToUnsignedChars(DFA14_maxS);
		private static readonly short[] DFA14_accept = DFA.UnpackEncodedString(DFA14_acceptS);
		private static readonly short[] DFA14_special = DFA.UnpackEncodedString(DFA14_specialS);
		private static readonly short[][] DFA14_transition;

		static DFA14()
		{
			int numStates = DFA14_transitionS.Length;
			DFA14_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA14_transition[i] = DFA.UnpackEncodedString(DFA14_transitionS[i]);
			}
		}

		public DFA14( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 14;
			this.eot = DFA14_eot;
			this.eof = DFA14_eof;
			this.min = DFA14_min;
			this.max = DFA14_max;
			this.accept = DFA14_accept;
			this.special = DFA14_special;
			this.transition = DFA14_transition;
		}

		public override string Description { get { return "143:1: repetition : ( ASTERISK number element -> ^( REPETITION_NODE element ZERO_OCCURENCES number ) |min= number ASTERISK max= number element -> ^( REPETITION_NODE element $min $max) | number ASTERISK element -> ^( REPETITION_NODE element number ORMORE_OCCURENCES ) | ASTERISK element -> ^( REPETITION_NODE element ZERO_OCCURENCES ORMORE_OCCURENCES ) | number element -> ^( REPETITION_NODE element number EXACT_OCCURENCES ) | element -> ^( REPETITION_NODE element ONE_OCCURENCE EXACT_OCCURENCES ) );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA23 : DFA
	{
		private const string DFA23_eotS =
			"\x6\xFFFF";
		private const string DFA23_eofS =
			"\x6\xFFFF";
		private const string DFA23_minS =
			"\x1\x9\x1\x23\x1\xD\x3\xFFFF";
		private const string DFA23_maxS =
			"\x1\x9\x1\x33\x1\x3C\x3\xFFFF";
		private const string DFA23_acceptS =
			"\x3\xFFFF\x1\x1\x1\x2\x1\x3";
		private const string DFA23_specialS =
			"\x6\xFFFF}>";
		private static readonly string[] DFA23_transitionS =
			{
				"\x1\x1",
				"\x1\x2\xF\xFFFF\x1\x2",
				"\x1\x5\x2\xFFFF\x1\x5\x1\x3\x11\xFFFF\x1\x2\xE\xFFFF\x1\x5\x1\x2\x2"+
				"\xFFFF\x1\x5\x1\x4\x1\x5\x3\xFFFF\x1\x5",
				"",
				"",
				""
			};

		private static readonly short[] DFA23_eot = DFA.UnpackEncodedString(DFA23_eotS);
		private static readonly short[] DFA23_eof = DFA.UnpackEncodedString(DFA23_eofS);
		private static readonly char[] DFA23_min = DFA.UnpackEncodedStringToUnsignedChars(DFA23_minS);
		private static readonly char[] DFA23_max = DFA.UnpackEncodedStringToUnsignedChars(DFA23_maxS);
		private static readonly short[] DFA23_accept = DFA.UnpackEncodedString(DFA23_acceptS);
		private static readonly short[] DFA23_special = DFA.UnpackEncodedString(DFA23_specialS);
		private static readonly short[][] DFA23_transition;

		static DFA23()
		{
			int numStates = DFA23_transitionS.Length;
			DFA23_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA23_transition[i] = DFA.UnpackEncodedString(DFA23_transitionS[i]);
			}
		}

		public DFA23( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 23;
			this.eot = DFA23_eot;
			this.eof = DFA23_eof;
			this.min = DFA23_min;
			this.max = DFA23_max;
			this.accept = DFA23_accept;
			this.special = DFA23_special;
			this.transition = DFA23_transition;
		}

		public override string Description { get { return "196:1: bin_val : ( BIN_VAL_PREFIX min= bin_val_number DASH max= bin_val_number -> ^( BIN_VAL_RANGE_NODE $min $max) | BIN_VAL_PREFIX bin_val_number ( '.' bin_val_number )+ -> ^( BIN_VAL_CONCAT_NODE ( bin_val_number )+ ) | BIN_VAL_PREFIX bin_val_number -> ^( BIN_VAL_NODE bin_val_number ) );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA26 : DFA
	{
		private const string DFA26_eotS =
			"\x6\xFFFF";
		private const string DFA26_eofS =
			"\x6\xFFFF";
		private const string DFA26_minS =
			"\x1\x15\x1\x23\x1\xD\x3\xFFFF";
		private const string DFA26_maxS =
			"\x1\x15\x1\x33\x1\x3C\x3\xFFFF";
		private const string DFA26_acceptS =
			"\x3\xFFFF\x1\x1\x1\x2\x1\x3";
		private const string DFA26_specialS =
			"\x6\xFFFF}>";
		private static readonly string[] DFA26_transitionS =
			{
				"\x1\x1",
				"\x1\x2\x4\xFFFF\x1\x2\xA\xFFFF\x1\x2",
				"\x1\x5\x2\xFFFF\x1\x5\x1\x3\x11\xFFFF\x1\x2\x4\xFFFF\x1\x2\x9\xFFFF"+
				"\x1\x5\x1\x2\x2\xFFFF\x1\x5\x1\x4\x1\x5\x3\xFFFF\x1\x5",
				"",
				"",
				""
			};

		private static readonly short[] DFA26_eot = DFA.UnpackEncodedString(DFA26_eotS);
		private static readonly short[] DFA26_eof = DFA.UnpackEncodedString(DFA26_eofS);
		private static readonly char[] DFA26_min = DFA.UnpackEncodedStringToUnsignedChars(DFA26_minS);
		private static readonly char[] DFA26_max = DFA.UnpackEncodedStringToUnsignedChars(DFA26_maxS);
		private static readonly short[] DFA26_accept = DFA.UnpackEncodedString(DFA26_acceptS);
		private static readonly short[] DFA26_special = DFA.UnpackEncodedString(DFA26_specialS);
		private static readonly short[][] DFA26_transition;

		static DFA26()
		{
			int numStates = DFA26_transitionS.Length;
			DFA26_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA26_transition[i] = DFA.UnpackEncodedString(DFA26_transitionS[i]);
			}
		}

		public DFA26( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 26;
			this.eot = DFA26_eot;
			this.eof = DFA26_eof;
			this.min = DFA26_min;
			this.max = DFA26_max;
			this.accept = DFA26_accept;
			this.special = DFA26_special;
			this.transition = DFA26_transition;
		}

		public override string Description { get { return "216:1: dec_val : ( DEC_VAL_PREFIX min= dec_val_number DASH max= dec_val_number -> ^( DEC_VAL_RANGE_NODE $min $max) | DEC_VAL_PREFIX dec_val_number ( '.' dec_val_number )+ -> ^( DEC_VAL_CONCAT_NODE ( dec_val_number )+ ) | DEC_VAL_PREFIX dec_val_number -> ^( DEC_VAL_NODE dec_val_number ) );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA29 : DFA
	{
		private const string DFA29_eotS =
			"\x6\xFFFF";
		private const string DFA29_eofS =
			"\x6\xFFFF";
		private const string DFA29_minS =
			"\x1\x1E\x1\x1A\x1\xD\x3\xFFFF";
		private const string DFA29_maxS =
			"\x1\x1E\x1\x33\x1\x3C\x3\xFFFF";
		private const string DFA29_acceptS =
			"\x3\xFFFF\x1\x1\x1\x2\x1\x3";
		private const string DFA29_specialS =
			"\x6\xFFFF}>";
		private static readonly string[] DFA29_transitionS =
			{
				"\x1\x1",
				"\x1\x2\x8\xFFFF\x1\x2\x4\xFFFF\x1\x2\xA\xFFFF\x1\x2",
				"\x1\x5\x2\xFFFF\x1\x5\x1\x3\x8\xFFFF\x1\x2\x8\xFFFF\x1\x2\x4\xFFFF\x1"+
				"\x2\x9\xFFFF\x1\x5\x1\x2\x2\xFFFF\x1\x5\x1\x4\x1\x5\x3\xFFFF\x1\x5",
				"",
				"",
				""
			};

		private static readonly short[] DFA29_eot = DFA.UnpackEncodedString(DFA29_eotS);
		private static readonly short[] DFA29_eof = DFA.UnpackEncodedString(DFA29_eofS);
		private static readonly char[] DFA29_min = DFA.UnpackEncodedStringToUnsignedChars(DFA29_minS);
		private static readonly char[] DFA29_max = DFA.UnpackEncodedStringToUnsignedChars(DFA29_maxS);
		private static readonly short[] DFA29_accept = DFA.UnpackEncodedString(DFA29_acceptS);
		private static readonly short[] DFA29_special = DFA.UnpackEncodedString(DFA29_specialS);
		private static readonly short[][] DFA29_transition;

		static DFA29()
		{
			int numStates = DFA29_transitionS.Length;
			DFA29_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA29_transition[i] = DFA.UnpackEncodedString(DFA29_transitionS[i]);
			}
		}

		public DFA29( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 29;
			this.eot = DFA29_eot;
			this.eof = DFA29_eof;
			this.min = DFA29_min;
			this.max = DFA29_max;
			this.accept = DFA29_accept;
			this.special = DFA29_special;
			this.transition = DFA29_transition;
		}

		public override string Description { get { return "234:1: hex_val : ( HEX_VAL_PREFIX min= hex_val_number DASH max= hex_val_number -> ^( HEX_VAL_RANGE_NODE $min $max) | HEX_VAL_PREFIX hex_val_number ( '.' hex_val_number )+ -> ^( HEX_VAL_CONCAT_NODE ( hex_val_number )+ ) | HEX_VAL_PREFIX hex_val_number -> ^( HEX_VAL_NODE hex_val_number ) );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _rulelist_in_start166 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rule_in_rulelist182 = new BitSet(new ulong[]{0x4008004012002UL});
		public static readonly BitSet _c_wsp_in_rulelist187 = new BitSet(new ulong[]{0x4000000012000UL});
		public static readonly BitSet _c_nl_in_rulelist194 = new BitSet(new ulong[]{0x4008004012002UL});
		public static readonly BitSet _rulename_in_rule221 = new BitSet(new ulong[]{0x604000000012000UL});
		public static readonly BitSet _defined_as_in_rule223 = new BitSet(new ulong[]{0x828038844200A20UL});
		public static readonly BitSet _elements_in_rule225 = new BitSet(new ulong[]{0x12000UL});
		public static readonly BitSet _c_nl_in_rule227 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rulechars_in_rulename257 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_rulechars279 = new BitSet(new ulong[]{0x8018804020002UL});
		public static readonly BitSet _c_wsp_in_defined_as331 = new BitSet(new ulong[]{0x604000000012000UL});
		public static readonly BitSet _set_in_defined_as334 = new BitSet(new ulong[]{0x4000000012002UL});
		public static readonly BitSet _c_wsp_in_defined_as344 = new BitSet(new ulong[]{0x4000000012002UL});
		public static readonly BitSet _alternation_in_elements365 = new BitSet(new ulong[]{0x4000000012002UL});
		public static readonly BitSet _c_wsp_in_elements372 = new BitSet(new ulong[]{0x4000000012002UL});
		public static readonly BitSet _WSP_in_c_wsp392 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _c_nl_in_c_wsp398 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _WSP_in_c_wsp400 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _comment_in_c_nl416 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CRLF_in_c_nl420 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMENT_in_comment437 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concatenation_in_alternation451 = new BitSet(new ulong[]{0x104000000012002UL});
		public static readonly BitSet _c_wsp_in_alternation455 = new BitSet(new ulong[]{0x104000000012000UL});
		public static readonly BitSet _56_in_alternation458 = new BitSet(new ulong[]{0x82C038844212A20UL});
		public static readonly BitSet _c_wsp_in_alternation460 = new BitSet(new ulong[]{0x82C038844212A20UL});
		public static readonly BitSet _concatenation_in_alternation463 = new BitSet(new ulong[]{0x104000000012002UL});
		public static readonly BitSet _repetition_in_concatenation489 = new BitSet(new ulong[]{0x4000000012002UL});
		public static readonly BitSet _c_wsp_in_concatenation493 = new BitSet(new ulong[]{0x82C038844212A20UL});
		public static readonly BitSet _repetition_in_concatenation496 = new BitSet(new ulong[]{0x4000000012002UL});
		public static readonly BitSet _ASTERISK_in_repetition522 = new BitSet(new ulong[]{0x8010800000000UL});
		public static readonly BitSet _number_in_repetition524 = new BitSet(new ulong[]{0x820028044200A00UL});
		public static readonly BitSet _element_in_repetition526 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _number_in_repetition563 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASTERISK_in_repetition565 = new BitSet(new ulong[]{0x8010800000000UL});
		public static readonly BitSet _number_in_repetition569 = new BitSet(new ulong[]{0x820028044200A00UL});
		public static readonly BitSet _element_in_repetition571 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _number_in_repetition591 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASTERISK_in_repetition593 = new BitSet(new ulong[]{0x820028044200A00UL});
		public static readonly BitSet _element_in_repetition595 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASTERISK_in_repetition628 = new BitSet(new ulong[]{0x820028044200A00UL});
		public static readonly BitSet _element_in_repetition630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _number_in_repetition670 = new BitSet(new ulong[]{0x820028044200A00UL});
		public static readonly BitSet _element_in_repetition672 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _element_in_repetition714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _number_val_in_number771 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rulename_in_element823 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_in_element829 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _option_in_element835 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _char_val_in_element841 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _num_val_in_element847 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _prose_val_in_element853 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _53_in_group867 = new BitSet(new ulong[]{0x82C038844212A20UL});
		public static readonly BitSet _c_wsp_in_group869 = new BitSet(new ulong[]{0x82C038844212A20UL});
		public static readonly BitSet _alternation_in_group872 = new BitSet(new ulong[]{0x44000000012000UL});
		public static readonly BitSet _c_wsp_in_group874 = new BitSet(new ulong[]{0x44000000012000UL});
		public static readonly BitSet _54_in_group877 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _59_in_option899 = new BitSet(new ulong[]{0x82C038844212A20UL});
		public static readonly BitSet _c_wsp_in_option901 = new BitSet(new ulong[]{0x82C038844212A20UL});
		public static readonly BitSet _alternation_in_option904 = new BitSet(new ulong[]{0x1004000000012000UL});
		public static readonly BitSet _c_wsp_in_option906 = new BitSet(new ulong[]{0x1004000000012000UL});
		public static readonly BitSet _60_in_option909 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bin_val_in_num_val933 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dec_val_in_num_val937 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _hex_val_in_num_val941 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_VAL_in_char_val957 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BIN_VAL_PREFIX_in_bin_val997 = new BitSet(new ulong[]{0x8000800000000UL});
		public static readonly BitSet _bin_val_number_in_bin_val1001 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _DASH_in_bin_val1003 = new BitSet(new ulong[]{0x8000800000000UL});
		public static readonly BitSet _bin_val_number_in_bin_val1007 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BIN_VAL_PREFIX_in_bin_val1025 = new BitSet(new ulong[]{0x8000800000000UL});
		public static readonly BitSet _bin_val_number_in_bin_val1027 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _55_in_bin_val1030 = new BitSet(new ulong[]{0x8000800000000UL});
		public static readonly BitSet _bin_val_number_in_bin_val1032 = new BitSet(new ulong[]{0x80000000000002UL});
		public static readonly BitSet _BIN_VAL_PREFIX_in_bin_val1053 = new BitSet(new ulong[]{0x8000800000000UL});
		public static readonly BitSet _bin_val_number_in_bin_val1055 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bin_number_in_bin_val_number1121 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_VAL_PREFIX_in_dec_val1169 = new BitSet(new ulong[]{0x8010800000000UL});
		public static readonly BitSet _dec_val_number_in_dec_val1173 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _DASH_in_dec_val1175 = new BitSet(new ulong[]{0x8010800000000UL});
		public static readonly BitSet _dec_val_number_in_dec_val1179 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_VAL_PREFIX_in_dec_val1197 = new BitSet(new ulong[]{0x8010800000000UL});
		public static readonly BitSet _dec_val_number_in_dec_val1199 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _55_in_dec_val1202 = new BitSet(new ulong[]{0x8010800000000UL});
		public static readonly BitSet _dec_val_number_in_dec_val1204 = new BitSet(new ulong[]{0x80000000000002UL});
		public static readonly BitSet _DEC_VAL_PREFIX_in_dec_val1225 = new BitSet(new ulong[]{0x8010800000000UL});
		public static readonly BitSet _dec_val_number_in_dec_val1227 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dec_number_in_dec_val_number1275 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HEX_VAL_PREFIX_in_hex_val1325 = new BitSet(new ulong[]{0x8010804000000UL});
		public static readonly BitSet _hex_val_number_in_hex_val1329 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _DASH_in_hex_val1331 = new BitSet(new ulong[]{0x8010804000000UL});
		public static readonly BitSet _hex_val_number_in_hex_val1335 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HEX_VAL_PREFIX_in_hex_val1353 = new BitSet(new ulong[]{0x8010804000000UL});
		public static readonly BitSet _hex_val_number_in_hex_val1355 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _55_in_hex_val1358 = new BitSet(new ulong[]{0x8010804000000UL});
		public static readonly BitSet _hex_val_number_in_hex_val1360 = new BitSet(new ulong[]{0x80000000000002UL});
		public static readonly BitSet _HEX_VAL_PREFIX_in_hex_val1381 = new BitSet(new ulong[]{0x8010804000000UL});
		public static readonly BitSet _hex_val_number_in_hex_val1383 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _hex_number_in_hex_val_number1431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PROSE_VAL_in_prose_val1485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _c_nl_in_synpred1_AbnfAst191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _c_wsp_in_synpred2_AbnfAst369 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
